Tengo que despejar mi escritorio. Un momento, así lo puedo... ¿Qué tenemos? ¿Qué tenemos? Jamboard, Barbara. Buenísimo, acá esto, genial. Barbara, excelente. Entonces, ahora, es bonito que me acomode el escritorio acá. Sí, la idea de la clase de hoy, vamos a terminar de completar algunos protocolos que asisten al protocolo IP, como son el protocolo ICMP, que es muy importante, vamos a hablar de ARP, y también vamos a ver el protocolo DHCP. Y si pudiéramos, después del break, la idea es terminar de completar la pintura en nuestras cabezas de cómo rutea la Internet real, con las cosas que hemos aprendido en nuestra Internet, que hemos probado en nuestros MiniNets. Así que ese es un poco el menú de la clase del día de hoy. A ver, screen, screen, screen. ¿Cuál es? Quiere ser esta. Bueno, díganme ahí cómo se ve, seguramente tengo que aumentar los fónticos. Bueno, vamos a ir tratando de switchar entre eso. Presentamos a ICMP, entre nosotros. Vamos, arrancamos entonces. ¿Alguien me recuerda el ICMP en qué capa está? El ICMP lo hemos introducido en algunas de nuestras discusiones. ¿Capa 3? Capa 3, sí. Decimos, a mí me gusta decir justo lo que está ahí en medio de la presentación, que es raro, porque es un protocolo que se llama InBand. Es como que se usa el mismo que lo transporta, que vendría a ser IP, para señalizarle el problema a quien lo transporta. Es InBand, no es que estamos usando otro canal, otro identificado protocolo, sino el mismo protocolo que yo quiero ayudar es el que me transporta a mí. Es el caso ICMP. Por eso es raro. Alguna gente lo ubica mal en transporte, porque no es un protocolo de transporte. Un protocolo de transporte siempre tiene pegado aplicación arriba. Está dedicado a transportar payloads de aplicación y ICMP no está para eso. ICMP es un protocolo que está al lado de IP. Es decir, está semánticamente, tal como bien me respondieron recién, está, es capa 3. Sin embargo, se escribe muy parecido a un protocolo de transporte. Es decir, si nosotros capturamos un paquete IP que cargue ICMP, si uno lo viera estrictamente desde la sintaxis, es decir, como lo escribimos, se vería muy parecido a un paquete UDP o TCP, sin embargo, no tiene nada que ver. Fundamentalmente, la presencia de ICMP es... La razón de su presencia es que, recordemos que IP es "stateless", es "connectionless". IP en sí no es orientado a conexión, porque yo no le pido a la red IP "dame una conexión". Yo, ¿cómo consumo la red IP? Yo, como consumidor de red IP. Si, como consumidor de red IP, yo me presento a la red IP y le tiro un problema. ¿Qué son esos problemas a la red IP que yo le tiro? Son, datagramas. Yo, para consumir el servicio de la red IP, yo nodo. Imagínense, yo soy un nodo. Tengo toda una red IP y tengo que llegar a otro nodo. ¿Qué es lo que le tiro como problema a la red IP? Le tiro conexiones, le tiro datagramas. Y ya sabemos, problema, un router empieza y termina con cada datagrama. Entonces, yo, como consumidor de la red IP, lo que le tiro son datagramas. No le pido conexión, le digo "che, red IP, hacés llegar esto a destino". Suerte, ya sabemos, ves este "for", no orientado a la conexión. Entonces, la razón de la presencia de ICMP es justamente para que la red me pueda, tenga alguna manera de decirme la red a mí, como consumidor de esa red IP, como nodo que consuma esa red IP, "che, estamos teniendo problemas con esto". "Che, no, no, esto que estás tra--, este datagrama que enviaste acá no tuvo suerte, no le fue bien. Fijate qué haces". Entonces, de alguna manera, si lo vemos a la red como un servicio, es lo que nos feedbackea de que hay algo que yo tengo que corregir como consumidor de esa red IP, como nodo, como endpoint, como host que consuma los servicios de la red IP. ¿Queda claro eso desde el punto de vista semántico, o sea, desde el punto de vista arquitectural, que es súper importante, porque de ahí vamos para el resto. ¿Sí? - Bien. - Sí, Pablo. Pablo, lo último es súper importante, que forma parte del hecho de que la red IP no hace ni más ni menos que hacer el mejor esfuerzo para hacer que un datagrama llegue a destino, pero no corrige nada. Y ICMP no está ahí para decir "ah, mirá, se te flipó este bit". Bueno, ya que estoy, te lo arreglo y te lo reencambio. No, no, no, no. Acá se tiró y lo reporto. No es el rol de IP más ICMP, que tendría que ser en definitiva la capa 3 de IP, IP más ICMP. No es el rol corregir nada. El rol es reportar para quien consume eso, el nodo que consume los servicios de la red IP, haga algo y sea él el que eventualmente corrija. Vamos a ver que en algunos casos puede hacer algunas correcciones. Por ejemplo, de la MTU, que hablamos en la clase pasada. Recuerdan que el nodo que observaba que había una depresión de MTU en el camino y que se le reportaba "che, no, no, a 1.500 no pasa". En realidad tenés que bajarlo porque yo el link que observo es de 1.400 y el nodo que está enviando, entonces puede ajustar. Y hay algunos casos que no. Entonces, eso es lo que vamos a explorar un poquito cuál es el scope, cuál es el ámbito de lo que hace ICMP en base a este reporte de errores que envía. Bien. Buenísimo. Entonces, ICMP, vale aclarar que no tiene, a diferencia de los protocolos de transporte de todo el stack TCP/IP, no tiene puertos porque justamente los puertos están de alguna manera, para los protocolos de transporte de todo este stack, están dedicados a asociarse con aplicaciones. Ya sea esa aplicación lado cliente, un browser, esa aplicación un lado server muy simplificado, un HTTP server en 80, un HTTPS server en 443. Sí, pero están ahí los puertos justamente para pegarse a cómo se usa desde una aplicación. Como ICMP no es un protocolo de transporte al servicio de aplicaciones, es un protocolo de soporte, de ayuda de IP, no tiene puertos, no necesita tener puertos, tiene un enfoque distinto de cómo cataloga, si se quiere, los distintos tipos de workloads que soporta o tipos de mensajes. Como ustedes bien pueden imaginarse, la red IP puede presentarse con muchas situaciones distintas y esto es lo que trata ICMP de cubrir. Vamos a ver estas situaciones distintas. Nuevamente, recuerden, a nosotros no nos interesa que se acuerden de memoria los números ni nada, pero sí que entendamos cuáles son las situaciones que presentan problemas en la red y cómo ICMP ayuda, cuál es la misión de protocolo ahí. Entonces, el mensaje ICMP ni siquiera es una cabecera porque es muy simple, lo pueden encontrar en internet, que es payload IP, entonces va a tener primero que es un campo que es el tipo de mensaje, después va a tener algo, algún adicional respecto del código de mensajes. Tipo y código. Los tipos son estos números, estos es un manozco de números, fíjense, 0 es un tipo, 3 es un tipo, 14 es uno de los tipos de mensajes y el código lo lleva detrás. Entonces, vamos a verlo. Raro que los muchachos, fíjense, el primer tipo que encontramos si lo vamos enumerando así secuencialmente desde 0 es Echo Reply. Echo Reply, ¿qué vendría a ser? ¿Qué se les ocurre? Fíjense que es el... Ahí dice, ping. Ping, ok. Y fíjense que es otro tipo, el Echo Request. Quiere decir que cuando yo hago un ping, el ping que bien conocemos, en realidad estoy mandando mensaje ICMP de tipo 8, cuando yo lo genero, y espero que me venga un ICMP de tipo 0. Es solo... a ver si... vamos a probar, no estoy seguro cómo lo va a mostrar. El sistema operativo y su manejo de ventanas, lo aborrezco. No sé, ya, chao. Paro de presentar un poco. Oh, my fucking gosh. Si alguien, nuevamente, si tienen alguien que les viene a decir que MacOS es un sistema operativo amigable al usuario, por favor, pónganme en contacto con esa persona. Ayer con un amigo, toda esa discusión. La puta madre, perdón, estamos grabando. No es amigable. Será amigable para, no sé, para mi viejo, ponele, para mis viejos, pero... Tiene unos comportamientos extrañísimos. El manejador de ventanas apesta, el sistema operativo no puede correr Docker razonablemente bien. Qué cosa, qué horrible. Y ahora, por ejemplo, cambié las ventanas para poner en foco el Shell, vieron que había separado en dos. Y esta que estaba presentando, no sé dónde dios la fue. No sé. Lo aborrezco realmente. Una cosa que no soporto. Bien. Es amigable si no lo usás. No, obviamente, todo es amigable de acuerdo a la audiencia, pero lo que yo discuto, y tengo muchos puntos para discutir, es que sea amigable para desarrolladores, que parece ser un caso de uso bastante típico para esta porquería del sistema operativo, pero bueno, nada. Ahí vamos. Bien. Para hacerlo un poquito más entretenido esto, vamos a... Vamos a hacer... Alguien que me pingue, por favor. Ya les... Ahí pueden ver la IP. ¿Cuál es mi IP? Ahí pueden ver. Esto es a propósito. Yo lo veo muy chiquito. ¿Ah, muy chiquito? Dale, muy chiquito. Vamos. Un momentico. Vamos. ¿Dónde ahí? Ahí, un toquecito más. Ahí. Bueno, buenísimo. ¿Cuál es mi IP? Esto es a propósito. Lo tiramos así porque esto... Nosotros ya tenemos que empezar a sintonizarnos la cabeza con poder decodificar lo que estamos viendo ahí en la pantalla. Fíjense cómo leo eso. Ah, mira, hay una ruta por default a través de... Ya sabemos, a través del router. Y para usar esa ruta por default, me presento con esta source IP. Por lo tanto, esa es la IP con la cual yo estoy en la red. De hecho, si ustedes tratan de parciar esto, fíjense que acá dice source, source, source. Están todos pegadas a la misma interfase. Entonces, evidentemente, yo tengo una única IP en esta interfase. Que es Ethernet algo, por eso empieza con "e". Que es esta. Así que, me pinge a vos, Diego, para que no se... Vamos a hacer lo siguiente. sudo tcpdump -interfaces/ncms/cmp A ver qué se ve. Vamos a agregar un "-n" para que no haga resolución de nombres. Hacés un ping, Diego. ¿Estás ahí, Diego? Parece que no. ¿Alguien que me haga un ping? El primer ping que se ve en la pantalla, alcanza. [PAUSA] Eso, gracias. Fíjense, ahí pueden ver, a lo corto, gracias a 0.193 que me ha hecho un ping. Acá pueden ver "icmp corequest", "icmp echo reply". Fíjense que en este caso, el mismo... ¿Cuál es el rol que ocupa tcpdump? Es lo mismo que han visto con WildShark el año pasado, que lo veían ustedes gráficamente. Lo que pasa es que es importante conocer la herramienta tcpdump porque, como hemos hablado muchas veces, no siempre, ustedes van a estar con una terminal gráfica contra lo que están tratando de bogear. Que a veces puede ser un router remoto que ni siquiera tiene una terminal gráfica, pero un router Cisco tiene un comando similar, o al menos, sí, tcpdump, muy parecido. Entonces es importante que uno se ponga a tono con estas herramientas que son de texto, si quiero, o de línea de comando. Entonces ahí se ve bien clarito, ¿no? "icmp corequest", "icmp echo reply". ¿Qué ven ahí? ¿Qué va cambiando de un paquete a otro, de un mensaje a otro? [PAUSA] La secuencia. La secuencia. ¿Y para qué se le ocurre que servirá esa secuencia? Y yo creo que es a un request con la primera secuencia, la primera respuesta, el segundo request. Fíjense que justamente si ustedes hacen... [RISA] Hemos habilitado IPv6 en la cloud, así que vamos a tener que sobrecargar los comandos con i4. Escuchame, -4 creo que era. [PAUSA] Bien. Justamente, fíjense cómo se los muestra cuando ustedes lo usan. Acá yo estaba debogeándolo, ¿no? Estaba TCP dampiándolo. Dampiando los paquetes y vemos que van y vienen. Acá está el número de secuencia, acá está la aplicación, cómo los usa. Lo que hace obviamente es para poder correlacionarse. Yo le mando un ping. Recordemos que acá no hay ni siquiera secuencialidad garantizada en la red. Entonces bien puede ser que el segundo ping venga antes, que la reply venga antes que el primero. Entonces, como en este caso estamos usando ICMP no para error reporting, sino para debugging, para diagnóstico. Entonces por eso es necesario sobrecargarlo con información que a mí me sirva justamente para encontrar eso. Y hemos visto algunos casos, hemos encontrado casos de data loss, especialmente si pingueamos a la luna. [PAUSA] Pingueamos a... Bueno, capaz que no lo tienen ni siquiera... Ah, sí, sí está. [PAUSA] Bueno, fíjense el tiempo. Está tardando. Ah, perdí un paquetito. Ah, perdí un paquetito. [PAUSA] No, bueno, no importa. 0% paqueto 2. Bueno, pero en definitiva, ¿qué queremos ver con esto? Queremos ver la secuencia... ¿Cuántos routers está más o menos en este destino? Digamos el pong. ¿Cuántos routers pasó? 1, 10, 100. [PAUSA] Ojo que no hice un traceroute, no voy a hacer un traceroute ni un mtr. [PAUSA] Y el time to leave era... Ahí no sé qué es 46. ¿Cuál era el default? Default era 64. Bueno, eso menos 46. Perfecto, perfecto. Es decir, unos 18, 20ish. ¿Sí? Más o menos. Eso, ojo, que este tl es del pong. Es decir, justamente del echo reply. [PAUSA] A ver si puedo esto mejorarle un poquitito. Voy a hacer una cosa para no presentar completo y no tener que insultar a este sistema operativo nuevamente. Voy a hacerlo así. Bien. Es decir, el echo reply este, que es un paquete fresco, la relación que tiene con el anterior se cocen entre los dos en base a tener source IP y destination IP cambiada y tener el mismo número de secuencia y tener el mismo tipo de protocolo. Es decir, 10 IP con el tipo este, nada más que 0 a 8. Pero este es un paquete de tipo 0 porque es un echo reply y que por default, asumimos que quien me hizo el pong le puso la misma cantidad de nafta que dicen los default de las RFCO, de 64. Por lo tanto, ha gastado 18 hops para llegar hasta acá. Bien, buenísimo. Bien, ping, ICMP es un caso particular de códigos, tipos de mensaje para diagnóstico. Bien, vamos al próximo que es uno de los más interesantes para explorar. Destination Unreachable. Destination Unreachable es justamente la red feedbackeándome diciendo, bueno, no puedo llegar a este destino. Más allá de esos cinco casos, lo que tienen súper interesante es que son casos, es el mismo tipo de error reportado, pero son casos profundamente distintos los escenarios en los cuales ocurre eso. Y ustedes, ustedes, para que apunto bien con el dedo así los inculpo, ustedes me van a decir qué diferencia hay entre esos casos. Vamos a empezar, ¿qué sería un destination network unreachable? Si yo estoy haciendo un, ojo, no un ping, estoy haciendo una conexión TCP, he hecho HTTP, etc. y estoy tratando de ir a un host destino con TCP y de pronto alguien me empieza a tirar destination unreachable network unreachable. Que no puede alcanzarlo. Ok, pero... La red no está adaptada a la rutea. ¿Qué significaría que, ajá, que es la network unreachable si lo comparamos, por ejemplo, con el que sigue? Por cierto, eso está en excepto el DF=1, que es un caso particular, que ya lo hablamos un poquito en la clase pasada. Net host protoport están como ordenados en cuanto al ámbito, ¿no? Mientras más grande todos los destinos que describe no reachable, hasta más chiquititos. Entonces, ¿qué sería network si lo comparáramos con host unreachable? Y network, por ejemplo, que se yo, quiero ir a la red 10.0.1.0, por ejemplo, no sé, /24, que quiero ir a esa red y no puedo, no puedo llegar porque no conozco el camino. Bien. Y el host sería sé llegar a esa red, pero no puedo llegar al equipo en específico. Bien, buenísimo. Muy buena aproximación. Efectivamente, es decir, tener presente que vos dijiste, pusiste un ejemplo, /24, que yo no tengo ese destino. Yo como router estoy en el medio de la cadena y me están pidiendo entregar este datagrama a un destino del cual yo no tengo ruta. Me está faltando una ruta entera. Yo no sé, quizás no sé si sea un /24, un /16, pero el tema es que yo no sé cómo busco en la tabla de ruteo y no tengo entrada en la tabla de ruteo. Es decir, bien hemos visto la tabla de ruteo, no tengo un default route, o bien podría ser que tengo una entrada en la tabla de ruteo específica a ese destino y tengo el link caído. Es decir, mi Ethernet link, por ejemplo, para llegar a ese destino está caído. Yo tengo entrada, me dice que la /24 está atrás de este link, pero está caído ahora. Entonces, no. O bien puede ser que directamente yo soy un router grandote, de esos que no tienen ruta por default, y sencillamente si se la busque, me retorno nada. Es decir, que yo como quien responde eso, y acá está interesante ver quiénes van respondiendo ese código. Es un router en el medio que sencillamente no puede hacer que ese datagrama siga su viaje. Porque no tiene una ruta, o la ruta está en una interfaz caída, como para que siga su viaje. ¿Qué diferencia tendría entonces con el próximo? Enfoquémonos ahora en Host Destination and Reach Out. Vos lo describiste bastante bien. ¿Cómo se presentaría ese escenario de que "Tengo ruta, pero no está el host, ¿qué pasó acá?" ¿Qué se les ocurre? Que no hay... No, no, dale, dale vos. Que no hay un host al cual se le haya asignado ese IP. Pero ¿cómo puedo estar tan seguro de eso? ¿Cómo puedo decir tajantemente... Yo, escenario es, acá el router, ¿no? El que dice "Che, no, esto es Host Destination and Reach Out en realidad, no es Network Destination and Reach Out, es Host". Pero ¿por qué puedo decirlo tan tajantemente? Decir "No, no es que sea la network, no es que no tenga ruta, es que el host no está". ¿Cuál es mi relación con ese host final como para poder decir tan taxativamente "No, el host no está"? Porque a la red sí se puede llegar, por ejemplo, llegamos al router y el router busca al host al que le pertenece, digamos, ese atarama, no lo encuentra, entonces responde... Pero tenés cuidado con lo que acabás de decir. El router no busca al host, que tenga una ruta específica del host. Busca un match en la tabla de ruteo. Si tiene un match en la tabla de ruteo y el link está arriba, seguro ya no es network, ¿no? Es decir, que encontró ruta, bien. Pero sin embargo, es capaz de decir "No, mirá, es el host el que no está". Entonces, la pregunta es ¿cuál es mi relación, yo como router, que respondo "host destination enriched" o "al origen", ¿cuál es mi relación con el host final? ¿Por qué puedo decir tan certeramente "No, no está el host"? Porque le mandamos el paquete y no responde. Y en qué momento... Bien, bien, bien. Pero en qué momento, de pronto, ¿cómo puede ser que un router ahora se ponga en súper académico y decir "Ah, no, le mando un paquete, no respondió". Cuando hemos dicho siempre que los routers, en realidad su problema es enviar el paquete y olvidarse. ¿Por qué ahora, en este caso, me dices "host", ¿qué le está pasando a ese router que no pudo así como desenvolverse el problema de reenviar ese paquete al próximo saltito y olvidarse? Y listo, y vamos con la próxima. ¿Por qué no me mandas el paquete? Porque no me mandas el paquete, porque no me mandas el paquete. ¿Por qué no me mandas el paquete? Porque no me mandas el paquete. ¿Por qué no me mandas el paquete? Porque no me mandas el paquete. ¿Por qué no me mandas el paquete? Porque no me mandas el paquete. ¿Por qué no me mandas el paquete? Porque no me mandas el paquete. ¿Por qué no me mandas el paquete? Porque no me mandas el paquete. ¿Por qué no me mandas el paquete? Porque no me mandas el paquete. ¿Por qué no me mandas el paquete? Porque no me mandas el paquete. ¿Por qué no me mandas el paquete? Porque no me mandas el paquete. ¿Por qué no me mandas el paquete? Porque no me mandas el paquete. ¿Por qué no me mandas el paquete? Porque no me mandas el paquete. ¿Por qué no me mandas el paquete? Porque no me mandas el paquete. ¿Por qué no me mandas el paquete? Porque no me mandas el paquete. ¿Por qué no me mandas el paquete? Porque no me mandas el paquete. ¿Qué tiene que ocurrir si es mi vecino el destino final? Porque no me mandas el paquete. ¿Cómo hago yo para entregarlo? Porque no me mandas el paquete. ¿Si es vecino mío? Por la red, por ejemplo, internet. Ok. ¿Y qué? ¿Lo "pfff" al casteo? ¿Así? No, si yo ya sé quién tiene señal de IP con una MAC. Bueno, si lo sé. Y si no lo sé, aún. Pero yo sé que es mi vecino. Y por ser mi vecino, cambia mi problema. ¿Sí? No tengo que pasarle el datagrama a otro router porque este ya es destino final. Es mi vecino, entonces voy a tener que preguntar. Eso lo vamos a ver ahora un ratito. Con un protocolo que se llama ARP voy a tener que resolver el mapeo de IP a MAC. Porque ahora sí, ya al ser mi vecino, yo tengo que encontrar esa MAC para poder hacerle el únicas y enviarle ese paquete al host destino final. ¿Sí? Es un esfuerzo distinto a enviárselo, es decir, el esfuerzo de resolución es más o menos el mismo enviárselo a otro router porque voy a tener que resolver la MAC. Pero el problema es distinto porque generalmente, yo como router final de toda la cadena, en el cual tengo potencialmente varios hosts en esta red final, yo voy a tener que resolver si este paquete, por ejemplo, está regresando, está siendo enviado a este host 1, host 2, host 3, host 4. Yo como router final de esa cadena voy a tener que tener ese mapeo de la IP a la MAC de cada uno de estos. Y si no lo tengo, voy a tener que construirlo. Voy a tener que ver cómo lo resuelvo. Y ese proceso de resolución puede tomar varios milisegundos. Con el protocolo de ARP. Entonces, ¿y cuál es el escenario entonces en el cual yo como router puedo decir, ah, no, host destination not reached. No respondió al ARP. Claro, o hubo algún tipo de timeout. Efectivamente, nadie respondió. Cuando yo grité, che, ¿quién tiene esta IP? Che, vecindad, ¿quién tiene esta IP? Y yo ya sé que es mi vecino. Clic, clic, clic, clic, clic, clic, timeout. Entonces, yo como router final, que yo sé positivamente que es mi vecino, respondo al origen no host destination reached. Se entiende, ¿no? Es muy distinto a buscar en la tabla de routeo y no encontrar un match y devolver network destination reached. Encontrar un match y ver que la interfase que me sale a ese prefijo está caída. Muy distinto al escenario. Siguen siendo los routers los que lo responden, pero es muy distinto. Vemos protocol destination reached. Este es un poco más difícil de tragar porque, ¿a qué se refiere con protocolo? Como protocolo de capa de transporte. Esto sería, por ejemplo, el caso, poco usual, porque la tecnología hoy en día nos ha puesto en otra situación, pero imaginemos que tenemos un, no sé, un censorcito súper básico de mínimo, mínimo costo, con muy poca memoria, súper optimizado, que es capaz que yo le puedo tirar un paquetito UDP y que me responda los valores de medición, no sé, de caudal de agua, de temperatura, no importa lo que fuera, en un paquetito UDP. Pero para ahorrar costos, no le he puesto una RASPI, una Raspberry Pi, ¿no? Sino que, como tengo que poner muchísimo, solamente tiene implementado el stack, tiene implementado lo súper básico. La capa de enlace, cualquiera sea con la que llega, puede ser radio o algún tipo de, no sé, Ethernet o Wi-Fi. La capa IP, UDP y una súper mini aplicación, que es esta que hace esto que yo les estoy comentando, que yo le puedo preguntar y me devuelve así un paquetito muy simple con las mediciones que tiene en el momento. ¿Qué va a pasar cuando yo intente hacerle un SCH a ese censor? SCH, SCH corre sobre TCP, ¿sí? Protocolo de transporte, que ya lo veremos, heavyweight, con timers, con corrección, con reenvío, con un montón de reglas. Cuando UDP es prácticamente, le agrega puertos a IP, UDP. Literalmente es así. UDP, lo vamos a ver, capa de transporte, es ponerle un par de puertitos a IP y sale con frita. No tiene retransmisión, no tiene timing, no tiene secuenciado, no tiene nada. A la capa IP ponerle una cascarita para que pueda usarse para transporte. Súper simple de implementar, pero súper simple. Entonces, yo voy a intentar, voy a decir, "ah, mira, este censor está caído". A ver, SCH, censor, @, la IP del censor y ¡pam! Protocol Destination Enrichment. ¿Quién me está respondiendo y quién me está respondiendo? Ya medio que me spoileé la respuesta, pero me gustaría que ustedes me lo digan. El host responde que ese protocolo no lo tiene soportado. Exactamente. Fíjense, acá está interesante porque es otra entidad de toda esta cadena quien responde. Antes habíamos visto los dos casos anteriores en el que respondía el router. En un caso el router sin ruta o caída y el último router vecino que dice "no encontré el destino que me pediste". Y acá el protocol Destination Enrichment, en realidad lo responde el host final y dice "yo no sé ese protocolo". "Mi no saber TCP", te dice el censorcito que solo implementa UDP. ¿Sí? Entonces, ¿qué chances de corrección tiene el origen? Ninguna. Lo mismo que en el otro caso. Acá el origen a lo sumo, en los otros dos casos, lo que puede hacer es bajar el ritmo de retransmisión. Es decir, host origen con network y con host Destination Enrichable puede decir, "ah, bueno, puede ser momentáneo este problema". En vez de retransmitir con tanta furia, yo le bajo el ritmo de transmisión cruzando los dedos que alguna vez se levante, se da la red o el host. En este caso, protocol Destination Enrichable te tiene que dar, puf, chau, no, listo. Muy poco, no voy a esperar hasta que alguien instale el TCP en ese host destino. Me dice que ese host destino no tiene protocolo, ya está, game over. No puedo hacerle ese SH a ese censorcito. Se entiende, ¿no? Fíjense cómo es de distinto. Lo que es raro, si quiere interesante, es que están todos dentro del tipo 3, como dice ahí. Están todos dentro del marco de no, yo red o conjunto protocolos no pude hacer llegar este datagrama destino. Vamos al próximo. ¿Qué será port Destination Enrichable? ¿Quién lo responderá? ¿Qué les parece? También el host. También el host, sí, sí. También el host y cuál es el, casi trivial, pero cuál es, qué es lo que observa el host. O qué es lo que intentaste hacer vos y por qué el host te dice port Destination Enrichable. ¿Y quise entrar para algún puerto que no está habilitado? No usemos la palabra habilitado, que no tiene ninguna aplicación asociada, que no está escuchado, que no está bindeado, no es una palabra en español, bindeado, pero no está tomado por alguna aplicación o servido por alguna aplicación. Habilitar o no habilitar, eso ya es otra historia, ¿no? Pero digamos, no hay nadie atendiendo en ese puerto. Entonces el host destino me dice, ¡pum!, no, ese puerto no hay nadie atendiendo, sorry. Y generalmente la actitud de quien intentó consumir ese puerto, intentó conectarse a ese puerto, es decir, game over, chau, no hay. Vamos a ver, vamos a ver sobre esto cuando hagamos TCP, porque TCP tiene su propio modo de hacer esto, así que eso se aplica solo para UDP y algunos otros protocolos, no para TCP. Pero no vamos a meter en eso, lo vemos luego. Y ahora me callo y alguien me explica el último porque ya lo vimos en la clase pasada. ¡Ah, qué bueno! Me voy a tomar unos mates. Y ese es el que hablamos de do fragmenting, que era uno, cero, para los routers saber si podían fragmentar los datagramas y que habíamos dicho que eso no tenía que poderse fragmentar. Bien, Df=1, recordemos lo escribe, es imperativo, y lo escribe quien inicia ese datagrama. Un host origen, contra un destino, dice, red, no me fragmentes esto. Tiene un campito específico, lo vimos en la clase pasada, es un campito que está acá en los flags, donde lo prendo en uno y yo le ordeno a la red que no me fragmente. Tenés la orden de no fragmentar. Si tuviera que fragmentar, por eso es "should fragment", directamente ese router lo descarta. Lo descarta y el mensaje que me viene es, el destino no se puede alcanzar porque debería fragmentar. Vamos a ver si lo podemos replicar a esto. -62000, no se me sale. -2, vamos a ver si estoy seguro que me va a alcanzar. ¡Ah, miren esa belleza! ¿Qué comando hice? ¿Se ve? Estoy compartiendo la pantalla completa, ¿cierto? -Sí, sí, se ve. -Perfecto. Ahí básicamente, ¿qué fue lo que hice? Hice un "mamping", ya saben, para ver las opciones, busqué ahí el Df, que es lo que estamos viendo ahora, "on fragment", y ahí busqué la opción, a ver cuál es la que es -m la opción, y "mdo prohibit fragmentation", "given local one". Vamos, esta es la local. Fíjense que esto me está dando algo interesante. ¿Dónde está esa "mtu"? Que esto no es una propiedad de ICMP, sino más bien de cómo Ping me está mostrando eso. "Ping local error message too long mtu" -En el propio host. -En el propio host, sí. De hecho, si ustedes lo ven acá, si ven acá las interfaces, van a ver, eso fue un IPA, acá te dice clarito "mtu 1458". Eso es porque al estar estas interfaces dentro de un mundo cloudístico, tenemos que encapsular, estamos usando VLANs para materializar las redes virtuales dentro de esta cloud, y no tenemos soporte más allá de 1500 en la tecnología que conecta los nodos que soportan la cloud. Si tuviéramos, podríamos hacer "jumbo frames" de 19000 y poder cargar 1500, es mtu 1500 en nuestras máquinas virtuales. No es el caso, por eso hemos tenido que disminuirla para poder meter ahí las cabeceras de encapsulamiento de VLAN, que es lo que estamos usando para materializar las redes virtuales que usamos en la cloud. Por eso es que tuvimos que "comernos" un pedazo del mtu para poder poner esas cabeceras del VLAN. Por eso es que, ahí me está diciendo clarito, vamos a ver si nos funciona la otra opción, si hacemos "mamping" y buscamos "df", acá me dice, ese yo usé la opción "do". Vamos a probar "want", a ver si logramos que este salga, pero yo es posible que... No, porque con 2000 no va a salir. Ahora vamos a intentar 1458. Creo que no va a pasar, tenés suerte porque esto es tamaño de pelo. ¿Qué pasó acá? "Truncated" ¿Qué significa eso? "Truncated", está diciendo que ha venido truncado, que esto ha podido hacerlo llegar, pero se ha truncado. ¿Por qué? Porque algo interesante que no está relacionado con ICMP, sino con cómo está implementado el ping y el pong, es que si ustedes... A ver... "Profe, ¿y por qué el TTL está en el top?" A ver... Ah, qué buena pregunta. Eso, qué bien, buena observación. Capaz que... Sí, capaz que Google no está respetando la de 64, es una recomendación. Una fuerte recomendación, pero no es una obligación. Capaz que habría que ver a cuánto estamos. En IPv4 de Google estamos a 12 hops. Así que 114 más 12 está usando, más o menos. Capaz está usando 128 o algo por el estilo, está duplicándolo. Pero uno tiene la posibilidad de cambiar ese default y se ve que así están corriendo las puntas de Google, las puntas que me está respondiendo el ping. Ah, no, aquí iba con esto. El ping es muy interesante porque... A ver si me permite ver... "Show payload" "Payload" "Content" ¿Alguien, por favor, que me haga un ping? Recuerden el IP, esta es la 10.200.1.3.2.2.5. Pero háganme el ping. Voy a TCPAMPAR y voy a TCPAMPAR un poco más violento. Voy a TCPAMPAR lo completo. Ya lo corro. Pero háganme un ping de tipo... "ping -pattern deadbiff" A ver si funciona esto. Ahí está. Este ping, lo que pasa es que alguien que me haga un "ping -p deadbiff" a mi IP que es 10.200.1.3.2.2.5. Necesito que alguien, por favor, me haga eso. Yo voy a TCPAMPAR acá esto. ¿Mando? Sí, sí, sí, ahí vamos. Ahí yo te hice. Eso quería mostrar. ¿Qué está ocurriendo ahí? Fíjense la cantidad de biff muerto que está viniendo ahí adentro. ¿Sí? La 270 me está haciendo ping, la 225. Y deadbiff, deadbiff, deadbiff, deadbiff, deadbiff. ¿Qué ocurre? Cuando ustedes pusieron el comando "ping -p" ustedes han decidido un patrón específico que quieren enviar porque lo que hace el Pong es replicarme el mismo patrón. Y eso me sirve a mí para detectar si hay "byte flipping" o si hay "byte flipping" en el patrón. Si hay "byte flipping", es decir, si hay bytes en la red que se estén cambiando y el comando "ping" espera que el Pong le replique, al esperar que el Pong replique exactamente lo mismo, se observa algún cambio, dice, acá en la red, acá hay algo que ha cambiado. Yo pedí que me reflejara este mismo contenido y no me lo hicieron. Fíjense, hágame un ping, por fa, ahora distinto. Hágame un ping menos, como era el tamaño, siempre me olvido. Menos "s", va. Un ping menos "s" 200, por ejemplo. Y sin el deadbiff. Voy a poner "tcpdump" con hexadecimal. Fíjense lo que está haciendo el ping. Fíjense que acá me mandó el diccionario, el diccionario me mandó letritas una tras otra. Lo que hace el ping es cargar su contenido justamente con esta secuencia, va mandando todos los bytes uno tras otro. Esto es obviamente el hexadecimal 14, 15 y 16. Me manda todo en secuencia con la idea de explorar todos los caracteres y que el Pong, fíjense que el echo request, que es el que vino acá, ustedes enviándome un ping a mí, el que me llega a mí, viene con esta secuencia de caracteres y yo como Pong, que hago el echo reply, estoy obligado a responder la misma secuencia de caracteres. Eso nuevamente es como para ver si la red está pasando bien el contenido de los autógrafos. Bueno, te lo quería mostrar. Esto nos debíamos un poco, pero era como para tratar de, lo que hicimos acá, lo que sí nos anduvo era este emdo, como para ver qué ocurría si yo intentaba enviar un ping más largo y hubiera que fragmentarlo. Vamos a la próxima. Otros tipos de acá, interesante para recalcar, echo request ya lo vimos, source quench. Se usaban los primeros, muy inicios tiempos de la Internet y servía para que la red me respondiera, "Che, hay congestión". Si yo estoy tratando, de vuelta, estoy tratando de usar la red contra un destino y alguien, algún router por ahí me dice "source quench, source quench, hay congestión, hay congestión". Y se ha dejado de usar por alguna razón. ¿A ustedes qué se les ocurre? ¿Cuál puede ser esa razón? ¿Cómo podrían abusar de source quench para molestar a sus vecinos? No vecinos de red, me refiero a los que comparten el link del proveedor de ustedes en su barrio, y ustedes saben de la existencia de su source quench y saben que se hace la casa a source quench, ¿cómo lo podrían abusar? Y tirando todo el tiempo un source quench, constantemente. ¿A quiénes? ¿Podría ser a un broadcast? No. ¿Puede ser? ¿No? No. Sería a todos aquellos que yo tendría que averiguar o estimar cuáles son las IP de las máquinas que hay alrededor mío, cuáles son las IP que usan, quizás no para el caso de una vecina del barrio, pero bien puede ser por una red compartida y vos sabés que acá no sé, todos, qué sé yo, usan un particular sistema o usan un sitio en particular porque están todo el día en Instagram por decir algo y yo tengo el set de IPs de Instagram, entonces dibujo ICMP diciéndole, "Mirá, cuando ustedes van a este IP destino de Instagram, la red te está tirando source quench y con eso arbitrariamente hacer que esas máquinas empiecen a bajar el ritmo porque dicen, "Uh, la red está congestionada para cuando yo voy a este IP destino". Esa es la razón por la cual se ha dejado usar básicamente en razón de seguridad. Como en realidad no confiamos en lo que dice la red per se y source quench era un mecanismo así como muy, muy, muy frágil, hoy prácticamente no se usa, pero estuvo ahí en su momento para tratar de hacer que la red me feedbacke de situación de congestión. Vamos a ver que en realidad TCP tiene otros mecanismos para detectar congestión que sí los usa. Redirect es el tipo 5, que es uno de los más interesantes para ver porque hay un juego de... de trío acá, si se quiere al menos. Bueno, a ver cómo empezamos con esto. Vamos a dibujar. Imagínense que esto es una red local, ¿no? Y acá tenemos un par de routers. Vamos a poner el dibujillo del router. Así que estos son dos routers. Y acá yo tengo una... Esto está súper simplificado, típicamente no es así, ya lo sabemos. Acá yo tengo una máquina. ¿Cómo puedo dibujar una máquina con esto? ¿Sí? Acá tengo mi... Bueno, este aquí es más horizontal y un monitor, ¿no? Este es mi máquina. Y resulta que esta máquina tiene... un router que me lleva a internet. Y tiene otro router, como bien estamos viendo aquí. Bien, estamos viendo ahí que hay dos routers que me llevan a la sucursal de San Rafael. Vamos a poner algunos numeritos acá. 132, 138, 01/24, está la red. Y la red donde estoy. Acá a esta le vamos a poner la 10. 10/24. Y le vamos a poner que este es el .254. Internet. Y a este que me lleva a la otra le vamos a poner .253. Siguiendo un poquitito esta convención, que no hay ninguna, es sencillamente esto que a nosotros nos gusta, en particular con Diego, de poner los dispositivos de ruteo en las últimas IP de una red. Bien, ok. La pregunta es, yo estoy acá, estoy parado acá en este... Recordemos, ¿no? La ruta siempre es donde estoy parado, donde quiero llegar y quién me lleva. Esta máquina, al igual que todo el resto de las máquinas, se autoconfigura. ¿Qué deberían tener como router? Por default, imaginando que es un sistema como... Típicamente es un sistema operativo simple, como incluso puede ser de un Android, o de algunos Windows, especialmente Windows más viejos, en el cual yo tengo que decidir ponerle uno solo como router por default, lo que normalmente conocemos la jerga como gateway. Si esto no es una máquina muy, si se quiere, sofisticada, entonces no me queda otra que ponerle uno de los dos. ¿Cuál le pongo? ¿El .253 o el .254? ¿Y por qué? ¿Por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. Se fija que la 10 está yendo por la .253, entonces lo manda esa router. Correcto. Sí, sí, lo manda esa router, lo manda la .253. Muy bien. .253 hace su laburo, donde su laburo es reenviarlo acá. Y ¿qué pasará con él? Como esto es una comunicación bidireccional, este datagrama va a seguir de la .2 a la .11 y la .2 a la .11 sigue este camino y se va hacia allá. ¿Qué pasará con el datagrama de respuesta de esto? Si esto es una conexión TCP, es un incremento, regresa, va y viene, como siempre en comunicación direccional. ¿Qué pasará cuando la .11? Yo lo voy a poner otro color porque son los datagramas de regreso. Me falta hacer acá el último caminito. Obviamente acá también hay un router al aterrizar ahí. Lo voy a dibujar para que quede completo. Obviamente acá la sucursal tiene su router. Y obviamente su router acá entonces es vecino. Este datagrama en este sentido sigue así. El router siendo vecino lo entregará a la .11. ¿Qué pasará entonces con la respuesta? Cuando se me tiene que responder en protocolo de transporte, un paquete, si quiere, complementario a esto, que tiene al revés origen y destino. Cuéntenme qué camino sigue. Y va cuando llega a la .253, la manda directo al host. ¿Por qué no va por el otro? Claro, el router ya sabe que es vecino. Es vecino, sí. Fíjense, ¿qué tal se ve este escenario? ¿Se ve bonito? Y no es el mejor, pero... No jodas, a ver, ¿duplicamos el tráfico en la red nada más? ¿O no duplicamos el tráfico en la red? En un sentido. Sí, porque en vez de hacer del .2 ir directo al .253, que sería uno solo, manda dos. Exactamente, es decir, que ocupamos el medio este, medio compartido, como sabemos, medio de internet. Lo ocupamos dos veces. Acá si hay alguien que se puede enojar, como sería mi caso si yo fuera el router .254, estaría muy enojado de que me busquen de queso. Yo soy router, loco, no soy secretario para poder llegar a nuestro vecino, ¿sí? ¿Se entiende, no? Porque me está usando a mí, no me está usando como router. Yo tengo claramente al menos dos interfaces, una de la red local y otra que nos lleva a internet. Y me está usando para levantar un datagrama y volverlo a tirar por el mismo enlace. Levanto el datagrama hacia el destino .11 remoto y lo tengo que bajar por el mismo enlace. ¿Por qué no hablás directamente con el .253, loco? ¿Qué podría hacer yo como .254 muy enojado y decirle a la .2 qué le debería decir? Che, tenés un router por allá. ¿Un router qué tiene? Está bien, tenés un router, pero ¿qué destino? Menos altos, claro, menos altos. Ok, está bien, es el router del destino, pero no le puedo decir al .254, a la .253, le digo, che, tenés un router en la .253 y la .2 va a decir, ¿un router de qué? ¿De qué me estás hablando? ¿Qué info le tengo que dar? Si yo quiero como .254 hacer bien la corrección de .2, si yo como .254 le quiero mostrar el dedito, como en las muestras políticas, cuando ustedes son como... Vaya por la .253, pero ¿qué cosa vaya por la .253? A la red 10. Ah, bueno, now we're talking. Quiere decir que para corregir este comportamiento catatónico, y tengan presente que si acá no hubiera una corrección, o un reporte para que éste corrija, esto sigue para siempre, ¿no? Si acá alguien no levanta el dedito, esto sigue para siempre, y si tengo muchas máquinas que necesitan enviar esto para el destino de la izquierda, nuestra red remota de la izquierda, van a ser el doble tráfico que se envía para todas esas. Entonces, ¿qué ocurre? Acá efectivamente vamos a tener entonces, esto es un ICMP, justamente es el ICMP que estamos ahora enfocados, que es el Redirect, un ICMP Redirect enviado por .254 a .2. Entonces... ICMP Redirect. Y dígame qué debería decir para que tenga sentido eso. Para que no me moleste más ese .2 para ninguna otra máquina de aquella red remota. ¿Qué debería decir ese Redirect? La red de destino y la IP del otro router, digamos. Es básicamente lo que tiene que decir una entrada en la tabla de ruteo, si se quiere. Tiene que decir, mirá, para llegar a ese destino tenés que ir vía... Un segundito. Qué feo que este dedito es por ahí. Ahí vamos. Vía quién? Ya lo sabemos esto. 0.2.53. Acá se da algo interesante y acá completamos la idea de quiénes son las entidades que escriben... No se puede acelerar la cinta, me va a decir un Redirect acá. Eso. Ahí está. Quiénes son las entidades que escriben entradas en la tabla de ruteo. Habíamos visto el humano, de hecho ustedes estuvieron ahí cuando estuvieron haciendo la práctica con Mininet. Ustedes escribieron la tabla de ruteo. El humano, una aplicación, protocolo de ruteo, que vendría a ser, si quieren, alguien que entiende todo el mapa del lugar donde estás y baja las entradas de ruteo para no hacer que el humano tenga que escribir todo. Y ICE, ICMP también. Eso es lo interesante. Fíjense como que de abajo ICMP provoca de pronto que este nodo de pronto tenga esta nueva entrada de ruteo. ¿A quién se le escribió? Se le escribió vía ICMP el que detectó que este Redirect estaba... Estaba... Digamos que esta máquina estaba mal usando este router. Entonces se le dijo, no, no, no, vos cuando quieras ir a la 10.0/24 anda a través de este. Y efectivamente si ustedes observan acá, de una manera especial, van a ver que se ha escrito una nueva entrada en la tabla de ruteo para corregir este error. Anto seguido es obvio lo que va a pasar. Si esto se ha escrito como una entrada de ruteo, ICMP nos hizo el favor de corregir esta entrada y obviamente esto ahora va a ocurrir así. ¿Cómo podrían abusar de esto para molestar a alguien que está en la red? ¿Cómo se ataca esto? Con eso no podría hacer de que todos los paquetes que se envíen primero pasen por mí y después, o sea, por un tema si yo quiero robar información o algo, no podría cambiarle... Dale, dale, veamos ese escenario. Es decir, vos sos un chico malo. Vamos a poner acá con rojo, espero que pueda, no sé si puedo dibujarlo con rojo. Es decir, vos estás acá. Y a vos te interesa hacer hijacking de alguna manera, de algo, de lo que puedas, de la punto 2. Vamos a simplificarlo. Cuando va al destino la 10/24. ¿Cómo podrías dibujar vos? ¿Qué deberías hacer vos para hacer que cuando la punto 2 va hacia ese destino 10/04/24 pase por papi? Por el rojo que está ahí. ¿Qué debería hacer? Debería enviarle un redirect diciéndole que cuando vayas a la 10.0 vía y le pongo mi PIN. Perfecto, buenísimo. ¿Y ese redirect de dónde viene? ¿Cuál es el origen de ese redirect? El host atacante. El punto 4. Y yo como punto 2 voy a decir "ay, quién sos vos punto 4, vos no sos ninguno de mis routers, me estás molestando al cuete". No te creo. ¿Y cómo hago para que punto 4 sea un poquitín más inteligente? ¿Cómo debería dibujar ese redirect? Y miento en el IP de origen. Ah, bueno, tengo que impersonar al router. Impersono al router, que ahí va a depender especialmente de switch ahí, porque hay algunos switch que pueden hacer policing de este tipo de cosas. Tienen un poquitito más, además de ser switches, pero bueno, más caritos, que me permitan hacer este tipo de cosas. Porque ahí yo voy a dibujar un datagrama, una mentira, básicamente construyo un ICMP de punto 4, pero no le pongo como origen yo punto 4. Porque yo punto 4 soy nadie para punto 2. Le pongo "sí, sí, sí, yo soy la 2.54" y cuando vos vayas a la 10.00/24, tenés que ir a través del router que está en la punto 4. ¿Y qué debería hacer la punto 4 entonces? ¿Qué debería hacer para qué? Cuando empiece, porque este, imaginemos que tiene éxito mi ataque, ¿qué debería hacer con las tracitas estas en celeste acá? Con los datagramas que envía la punto 2 a la punto 10. ¿Tragárselos todos y no enviarlos? No, para guardarlos. No, no, debería mandarlos. Si quiero hacer un buen hijacking, obviamente tengo que hacer, así con el halo de inocencia, levantarlo, convertirme en el router ese, y levantarlo, observarlo, guardarlo, hacer la maldad que quiera hacer, y después obviamente hacerle seguir su camino de tal manera que punto 2 no se entere de que estoy en el medio de eso. Y eso sería efectivamente, sería posiblemente un ataque exitoso, a menos que alguien en el medio me haga algún policing de que si lo quiero hacer bien, bien, bien, además de escribir ese paquete, yo soy la punto 4, la roja, ¿no? Además de decir, che, esto viene de la 2.54, pero no solo debería hacerle IP, además, ¿qué debería ponerle como origen 2.54 para hacerlo creíble? La MAC de 2.54. Para hacerlo más parecido, tengo que impersonarlo en todas las capas, ¿no? En capa 3 sería ponerle IP origen y en capa 2 sería ponerle MAC origen del router, que yo la puedo saber. Pero ahí es donde me las puedo ver con un switch que diga, ¿cómo que está viniendo una MAC origen acá? Si yo sé que vos no estás acá, sabemos que el switch memoriza las MACs. Entonces ahí puedo, dependiendo de cuán elaborado sea el switch, cuánto este tipo de protecciones tenga para hacer anti-spoofing, se llama eso, el switch mismo puede rechazar que vos dibujes una MAC que no te corresponde. Porque ha aprendido del intercambio bidireccional que vos no sos esa MAC. Y de pronto me estás enchufando una MAC que yo he aprendido positivamente que está en este otro puerto. Entonces el switch mismo te puede llegar a rebotar a esa trama y tirarlo al piso. Y ahí está la diferencia entre switch que compro en un blister en Electrónica Mendoza, versus un switch que compro, no sé, en una casa de distribución o en un mercado libre que me sale 10 veces más. ¿Y qué pasa si ese switch arranca y encuentra que tiene la misma MAC en dos puertos? Dependería de la tecnología del switch, pero capaz que se deagradea flooding. Generalmente más que flooding, en los dos va a ir flipando entre uno y otro. Si es lo más básico, ahí sí funcionaría el ataque, digamos, porque no tiene memorizada la MAC. Y si lográs sobrescribir al router con más tráfico, es posible que lo fullees, es decir, que lo tontees al switch para que crea que vos sos esa MAC. De hecho, acá hay una gran comunidad de amigos en Ethernet. Somos una comunidad de amigos, y acá estoy poniendo un enemigo. Ethernet, en general, igual que IP sin mecanismos de autenticación o de securización como IPsec, es una gran comunidad de amigos. Así que sí, totalmente. De hecho, cualquier sistema operativo te permite hoy, con las placas que tenemos hoy, cambiar la MAC que estás usando, se llama cloneo de MAC. Generalmente, vos directamente podrías plantearte acá, en vez de ponerte con todas estas cosas de ICMP que aprendí en teleinformática, le planto la MAC del router así, violento, porque la placa me lo permite, y empiezo a tirar mucho más tráfico a la red, me comporto como un router para, por decirle, ganarle a ese router. Puede que tenga éxito o no, va a ser mi problema después, como llego al router, si tengo la misma MAC del router y creo, quiero que estos datagramas tengan éxito, porque voy a tener que escribir, ¿cómo voy a llegar al router? Yo le piso la MAC al router, yo. Si quiero impersonar el router 254, después ya no me puedo comunicar con él, porque le estoy robando su MAC. No tengo manera de mandar un unicast de mi misma MAC a mi misma MAC, pero no es mi MAC, es la MAC que está allá, en aquel puerto. No es posible. Entonces, bueno, no es foco, no es una materia de seguridad esta, pero sí es interesante que veamos las consecuencias que tienen algunas decisiones. Este es un protocolo simple, una corrección simple, y que por ser simple y efectiva, pero deja un montón de espacio para potenciales ataques de este tipo. Y se los menciono porque es un ataque que ustedes pueden llegar a sufrir cuando estén implementando algo como esto. Y de paso nos permite entender un poco más el rol y cómo funciona. Vamos al próximo. Esto está... acá hay un problema de... Bien, el 11 ya lo conocemos. ¿Cómo me traducen al coloquial el 11 para ttl=0? ¿Qué caso es ese? De vuelta a la red, corrigiéndome, me manda un 11, time exceeded in transit. ¿Qué? Dale Javi, vos. Es el que se echa del paquete, digamos, porque ya está como perdido. No es como perdido, es algo muy específico. Ha quedado como en un loop que está saltando entre varios routes. Puede ser, o sencillamente podría ser un loop. Yo no sé qué ha pasado. Lo que sé es que se le terminó el ttl. Esto que nosotros le llamamos la nafta, es 64 por default. Ya sea por un loop, que puede ser, o porque sencillamente quien escribió el ttl en origen, de hecho lo hacemos explícitamente cuando hacemos un comando trace route, como hemos hablado mucho, el mtr, le vamos poniendo distintos ttl, 1, 2, 3, 4, para descubrir la red, y ahí no hay ningún loop, es sencillamente una cuestión de diagnóstico. Y efectivamente el router que lo tira, porque dice "se le terminó el ttl", se le acabó la nafta, este datagrama, envía un 11 de regreso. ¿Sí? Time exceeded in transit. Time, time, ¿sí? De vuelta, esto está mal. No hay tiempo acá, es hops, cantidad de hops en este caso. Lo que es interesante del otro, que el otro sí, es time. Fíjense, el tipo 11 en realidad contempla dos casos distintos. Un caso es el que hemos hablado muchas veces, que se le acaba la nafta, el router lo descarta y envía un mensaje al origen. Y el segundo también lo hemos hablado. ¿De qué se trata el segundo? Está ahí. Se quedó mucho tiempo esperando y... ¿Esperando qué? El... fin de la... no. Uy, se me olvidó. Un fragmento, se quedó mucho tiempo esperando un fragmento. Exactamente todo lo que estuvimos discutiendo el caso del pasado. Se rompió en pedazos un datagrama, llegaron, viajan los fragmentitos y el destino no pudo comprender todos los fragmentos para reconstruir el datagrama. Hizo timeout, entonces el host destino le dice al origen, "Mirá, acá no pude reensamblar los fragmentos de este datagrama". ¿Sí? Bien. Seguimos. Parámetro problem es... Loco, no sabés escribir el protocolo. Parámetro problem es cuando le pones algo inválido. ¿Sí? Ahí también, por una cuestión de seguridad, puede ser que lo responda o no. Es una decisión un poco del host destino. Dependerá. Dependerá, pero puede ser cuando yo estoy escribiendo la cabecera de un protocolo, por ejemplo, le he puesto justamente un campo, sería "field invalid", sería el parámetro problem, entonces el destino puede llegar a responder "Mirá, me has enviado un datagrama que tiene este problema de parámetros. Aprendé a escribir el protocolo". Si eso es lo que me está diciendo. No es muy usado realmente. TimestampRequest y TimestampReply están en el mismo ámbito, más o menos, del Echorequest y Echoreply. Y, en realidad, se puede usar para medir timing, aunque ya con la sobrecarga de data que tiene Echorequest y Echoreply ya se puede hacer timing. Básicamente, el 13 en el 14, el 13 lo que le pone es estampa de tiempo donde estoy yo, y le pide al destino que cuando le responda le copie la estampa de tiempo para hacer una medición mucho más precisa de a qué distancia de tiempo estamos nosotros dos. Yo con mi destino. Poco usado. Se puede usar también, pero en realidad, como se usa ICMP, Echorequest y Reply suele ser suficiente. Así que uno tenga alguna herramienta que lo termine usando esto. No sé si ping puede flipar. El comando ping, la implementación puede flipar a eso. IP, no, pero es de capo IP, no es ICMP eso, no. Seguimos. Bueno, básicamente y con esto completamos ICMP. Antes de cerrarlo, entonces queda bien claro el rol que cumple ICMP. ICMP ahí como un protocolo de, ya sea de diagnóstico o de reporte de error que le permite a la red expresar condiciones anómalas para quienes usan la red podrán corregir esas condiciones. Vamos a ARP. ARP es... Lo hemos hablado indirectamente muchas veces y básicamente responde a esta pregunta, ¿no? La pregunta es, ¿quién tiene, quién de aquí? Y alguien me va a decir a qué me refiero con de aquí. ¿Quién de aquí tiene este IP? Y alguien levanta la mano, me hace un reply y me dice, "Che, yo estoy en tal MAC". ¿Qué sería ese de aquí? ¿Quién de aquí? ¿A quién me estoy refiriendo con el de aquí? De esta vecindad. ¿Quién de...? No, de cualquier lado del internet, ¿no? Porque obviamente el problema de MAC de capa 2 es solamente mi vecindad. Entonces, yo le pregunto a mi vecindad, ¿quién de aquí tiene esta IP? Y veamos cómo... Yo voy a... Para poder ver cuáles son las máquinas de mi vecindad que he aprendido, puedo usar el comando ipnate neighbor. IPN. ¿Sí? Y eso básicamente le estoy preguntando a mi kernel de mi máquina, ¿cuál es...? ¿Quiénes de mi vecindad he aprendido? A ver, ¿quiénes me pinguearon? Me pinguearon... ¿No me pinguean, por favor? Ahora, porque quiero mostrarles lo que pasa. Oh, demasiado. ¿Vos me tiran algún IP? Pero no me hagan ping, porfis. ¿Me dicen algún IP de los vecinos acá míos? ¿De los que están guardados? No, IP de ustedes. Tírenme un IP. 10.201.3.83 3.83, gracias. Yo voy a dejar corriendo en background. TCP Dump, con lo cual acá las alias se van a mezclar un poco, pero bueno, como parte también de lo que tenemos. Voy a hacer un solo ping. Ahora, 10.201.3.53, ¿me dijiste? 83. Fíjense que lo que pasó ahí. Ahí se mezcló un poco, ¿no? Estas son las... Este es el ping mismo. Voy a cortar. Se ha mezclado el ping, que es este, con el TCP Dump, que está acá. Pero fíjense qué ocurrió. El TCP Dump yo había dejado corriendo en background, con este simbolito, este ampersand. Un TCP Dump le había dicho, "Dumpeame de la interfaz de internet todo lo que sea ARP, por lo cual lo estamos viendo ahora. Y acá está justamente lo que escribió ARP. Básicamente yo tuve el problema de decir, "Bueno, mi máquina, mi kernel, que implementa IP, y obviamente hemos hablado de todas las capas de protocolo de estacto de cipa IP, las capas de transporte para abajo. Cuando voy a mi vecino 383, tengo que resolverlo, tengo que ver dónde está. Entonces yo mandé un request. ¿Quién tiene la 383? Dijo quién. Yo, esta es mi IP. Y acá alguien me hizo este reply. Díganme, estos paquetes, ¿son los dos de broadcast? ¿Son los dos de unicast? Respecto de ethernet. >> Uno es broadcast y el otro es unicast. >> ¿Cómo, cuál es cuál? >> El que uso para preguntar quién lo tiene, ese es broadcast. >> Ajá. Eso es obvio, ¿no? Porque obviamente al no saber quién lo tiene, estoy preguntando a quién, así que lo broadcasteo a toda mi vecindad. Ahí lo vamos a confirmar como broadcast, aumentando un poquitito el TCP AMP. Y el otro, quien responde, ya no hace falta que él responda a toda la vecindad, porque ya aprendió todo de mí. Yo pregunté, "Che, ¿quién tiene la 383?" Y la 383, que la recibió en broadcast, lo levantó, ya sabe quién preguntó, por lo tanto responde con unicast. No hace falta que responda con broadcast. Y recordemos, broadcast también es otro de los caca nene, no usar a menos que haga falta, y en este caso hace falta en el primero, pero no en la respuesta. Yo voy a sobrecargar un poco. Voy a limpiar de vuelta, ese es un flush de mi tabla de vecindades. Fíjense que el único que me quedó reachable es el router por el cual yo estoy entrando, así que tiene que haberlo resuelto. Yo hago un flush, pero ha seguido, ya reachable por el intercambio de paquetes que yo tengo contra este host, no le queda otro. Voy a hacer el mismo ping, el mismo TCP AMP antes, pero le voy a agregar un parámetro que es -e. -e es para que muestre las cabeceras, el encapsulado de capa 2. Vamos a hacer el mismo ping. Fíjense qué ha pasado ahora. Fíjense que ahora, si buscamos acá donde dice ARP, que es esto de acá, se ve bien clarito que acá una Mac, que es la mía, tiró un broadcast a todos. Oh, come on, eso fue por selección. Tiró un broadcast preguntando quién tiene esa, preguntó yo. Y acá hay un únicas de respuesta, esto que está acá, donde justamente ese únicas viene hacia mí, desde el destino que lo tiene y dice, la 383 está en esta Mac. Entonces, ¿qué es lo que hace este host, mi máquina? Lo que hace es efectivamente guardarlo en la tabla. Acá está él porque como no lo he vuelto a usar, está ahí abajo para confirmar. Él quiere decir que lo escribí, vamos, que lo escribí, pero que no he tenido mayor, baja interacción como para confirmar que sea cierto. Sí, cuénteme, pregunta. Ahí responde que, o sea, is@ y la Mac. Sí. Pero vemos en la cabecera que responde una Mac. Eso es porque puede responder otra Mac diciendo quién tiene. Es una cuestión de, bueno, ARP tiene en realidad otros usos que respondería mejor a tu pregunta, que no los vamos a ver porque ya se han dejado de usar. Pero en realidad es una cuestión más de encapsulamiento. Podría ser el caso, pero es más para decir que quien desencapsule esto, la interpretación del protocolo ARP, no tenga que fijarse en las cabeceras de enlace por el cual llegaron. Ah, está bien. No tenga que decir, che, capa de más abajo, ¿de quién vino? Sino que sea autocontenido. Digamos, la capa del protocolo ARP va a leer, por decir una manera bruta, va a leer de acá para adelante lo que acabo de editar acá. Entonces, va a decir, listo, ya me lo contiene. No tengo que ir a preguntarle abajo, che, ¿y quién mandó esto? Es más rápido. Por una cuestión de encapsulamiento de protocolos, de layerización, si se quiere. Una pregunta. Esto básicamente es un cache, un caché, ¿no? Sí, ¿no? Es como una especie de base de datos, pero caché, caché siempre tiene involucrado tiempo. Porque acá hay tiempos involucrados. O hagámoslo al revés, yo le digo. Esto es un caché. Como todo caché tiene fundamentalmente dos dimensiones. Tamaño y tiempo. Y quiero que exploremos ambas. Tiempo. ¿Cuánto almaceno esto para siempre? No, yo creo que, por ejemplo, el router lo puedo configurar para que después de qué cantidad de tiempo se vuelva a dar IPs. No, pero eso es otra cosa. Eso no tiene nada que ver con lo que estamos viendo ahora. Entregar IPs a otro protocolo de HCP que lo veremos. Acá imaginemos que no hay, imaginemos por ejemplo, si lo queremos simplificar, que todas las IPs están prefijadas. Están escritas duras en la configuración de cada máquina. No hay un pool de IPs que se entrega. Porque es otro el problema. La pregunta es, ¿cuánto lo memorizo acá? Un microsegundo, diez milisegundos, un segundo, diez días para siempre. ¿Eso no está en el protocolo? No sé, yo quiero que ustedes me digan qué valor puede ser razonable. Muy cortito, mediano, infinito. Unos 30 segundos. ¿Por qué no lo hacemos infinito? No tiene sentido 30 segundos, porque si no cada vez... O sea, si yo al ratito quiero volver a mandarle un paquete a él mismo, lo tengo que volver a preguntar. Bueno, es una razón para que no sea tan pequeño. ¿Cuál sería una razón para que sea una estupidez que sea medio segundo o diez milisegundos? Porque decían, ah no, que dure lo necesario para enviar este paquete. Pero ¿qué va a pasar con el segundo paquete? Voy a tener que hacer todo el esfuerzo. Que es bastante esfuerzo, fíjense que hay dos paquetes, dos tramas que ocupan espacio en la red para resolver esto. No sé si ocupa espacio, bueno, hagámoslo infinito entonces. Ya está. Hasta que no se rebotee la máquina. Claro, sí, puede ser. El tema es que... ¿Qué pasaría en ese caso? Y se podría llenar la memoria. Ponele, bien. Pero es otra dimensión. Yo estoy hablando ahora, discutiendo dimensión-tiempo, no dimensión-tamaño. Ya discutiremos dimensión-tamaño. Dimensión-tiempo. Infinito. No sé... No sé si tiene mucho sentido el tiempo o cuando yo quiera enviar algo a esa IP y ya no tenga esa MAC... Pero entonces, volvemos al problema. Si no tengo esa MAC, quiere decir que lo memorizo cero. Cada vez que envío un datagrama, tengo que hacer el esfuerzo de ARP. No, digo que cuando yo quiero enviar algo a esa IP y no obtengo respuesta o veo que no está, ahí recién volver a preguntar y borrar esa entrada. Yo soy IP y le pido... IP le pide ayuda a ARP para esto, ¿no? Pero vos estás pidiéndole demasiada memoria a IP. IP no memoriza. Bufferea un poco hasta que resuelve y listo, ¿no? Pero IP no tiene tanta inteligencia como lo estás pidiendo vos. Decís "si veo que no me respondieron entonces, no sé qué". ¿Cómo sé yo? A ver, escenario es el siguiente. Este es el siguiente escenario. Lo almaceno para siempre. Con lo cual yo, lo que estamos leyendo acá, este host se quedó para siempre con la idea de que esta IP, la 383, está atrás de esa MAC. ¿Sí? Y cada vez que quiera ir contra la 383, le planta esa MAC y lo envía. IP no sabe si llegó o no llegó. No tiene un feedback. ¿Qué feedback puede tener? ¿Si es protocolo de red? No tiene un hack IP. Entonces no puedo implementar lo que vos estás sugiriendo porque yo no sé si fue, vino. Porque mi misión fue, lamentablemente, como ese es vecino, tuve que resolverlo, lo resolví, lo guardé para siempre, planté la MAC, se lo tiré al switch, fin de mi problema. Ya está. Entonces vamos de vuelta al infinito. ¿Qué problema puede tener el infinito? O no tiene ningún problema. El tamaño de la memoria. No, estamos discutiendo tamaño ahora. Imaginemos una red de 10 vecinos. Ya discutiremos el tamaño. ¿Que cambie qué? ¿Cambie la MAC? Cambie la MAC no es problema porque lo resuelvo de vuelta. Si vos, tu máquina, redeployás esa instancia y me decís "Prof, ahora tengo la .92, listo, la resuelvo, ya está, y la almaceno para siempre". ¿Cuál es el problema acá? Que cambie la MAC. Cambie la MAC manteniendo la misma IP. ¿Por qué? Porque yo me la he memorizado para siempre esa relación. La he escrito con piedra, o hasta que reboté la máquina, no sé. Entonces, al memorizarla para siempre, ya no la resuelvo más. Entonces, si vos, y bien puede ser, y ahora sí se les enero que alguien mencionaba de que hay IPs que van y que vienen. Si estas son IPs que se entregan y que expiran, como generalmente es una red, bien puede ser que venga otra máquina, como cuando ustedes iban a la facultad con sus notebooks, se les prestaba una IP a traer un protocolo que luego veremos, de HCP, por un determinado tiempo, 6 horas, 12 horas, después de la cual, en realidad, ya no tienen más permisos para usar ese IP y ese IP se le puede entregar a otra máquina. Si el resto de la red memoriza que la relación IP MAC, que obviamente la MAC de tu notebook es distinta a la MAC de tu compañero, que en distintos momentos de tiempo obtuvieron la misma IP, obviamente si se almacena esa relación dura en otros que participan de la red, esto no va a funcionar, eso tiene que expirar. Entonces, este ejercicio que solemos hacer para tratar de entender el problema de irnos a los extremos, de qué pasa si es muy muy cortito, y qué pasa si es infinito o muy grande, está bueno justamente porque nos permite encontrar ese compromiso. Y ese compromiso hace que esto, en realidad, sea de unos minutos. No me acuerdo, la RFC, pero en el orden de minutos. Fíjense que todavía está medio "stale" ahí, pero probablemente si nos vamos a recrude y volvemos ya haya desaparecido de acá. Entonces, está en el orden de minutos, más o menos, de esa memorización. Justamente para permitir esta flexibilidad de que la misma IP esté en otra MAC. Como todo caché, entonces habíamos dicho, la otra dimensión, la dimensión tamaño, que esa es más simple y es la que algunos sugirieron. Este caché tiene un tamaño... ¿Cómo debería estar "sizeado" este tamaño? ¿A qué debería ser, entre comillas, "proporcional"? Al tamaño de la red. ¿Qué es el tamaño de la red? ¿El tamaño de toda la internet? No, o sea, la cantidad de vecinos que pueda tener. Bien, ok. Y eso va a estar relacionado con la máscara, ¿sí? Para R24, sabemos que tiene un máximo de X. De todas maneras, esto es KPIP, esto es ARP, pero es como para ver los órdenes de magnitud. A mí me ha pasado de ver ocurrir en redes muy anchas, como bien puede ser esta red virtual, pero ahora, en realidad, con la memoria de esta red es tan ancha como 65K, y probablemente si tuviéramos 60 y pico K, o muchas decenas de K de nodos en esta red, habría problemas de ARP. Perdón, del caché de ARP, de la memoria de ARP, que sencillamente haga overflow. Si yo tengo, y ahí es donde viene ya un diseño de, ¿qué hago? Si yo tengo que comunicar muchas máquinas, si piensan que no necesariamente son nodos, máquinas finales, sino pueden ser dispositivos móviles. Y tengo una red donde va a haber mucho, como puede ser, no sé, una red municipal, ¿sí? Cuando ustedes van y tienen la Wi-Fi de la ciudad de Mendoza en una plaza, Plaza Martín, por decir algo. Y ahí bien puede ser una red de mucha densidad, muchas vecindades, ¿no? ¿Cómo manejo? Trato de crear áreas donde yo tenga distintas vecindades, rutea entre sí, o creo una gran vecindad, y bueno, están estos desafíos. Me puedo encontrar con dispositivos que tienen una capacidad limitada de vecinos, sin embargo, en un escenario como este no se aplicaría. ¿Por qué no se aplicaría ese problema y funcionaría igual? El escenario es este. Ciudad de Mendoza poniendo Wi-Fi, pone una gran barra 16, y de pronto, no sé, hay una manifestación, estamos todos sacando las fotos, subiendo fotos de la manifestación de esto, no sé. 3.000 personas. ¿Es problema o no es problema? En este caso particular, en esta aplicación particular. ¿Cuál es la vecindad que esos Android o iPhone tienen que resolver? ¿Tienen que resolver los miles de vecinos de esa misma red? No, porque no le van a estar enviando datos a todos. OK. Salvo que estemos usando algún tipo de protocolo de mesh o algo por el estilo, en el cual, no sé, estemos usando alguna de estas cosas locas que te permiten compartir directo de dispositivo a dispositivo, encontrarte vos mismo en la red, que no es así típicamente. Típicamente vamos a estar subiendo la fotito a Instagram, mostrando o a Facebook o a lo que sea, o a TikTok, el video. ¿Y para eso a quién voy a tener que resolver en la red? Y al root, al default gateway. Entonces, típicamente estos dispositivos solamente van a tener una entradita que es la del default gateway, porque básicamente la red la usa para encontrar el default gateway y después de ahí enviar los altagramas hacia el exterior y después el default gateway me los enviará a mí y será. ¿De quién va a ser el problema el tamaño de la vecindad? No va a ser el problema de mi Android. ¿De quién va a ser un poco el problema? Del router. Porque el router va a tener una vecindad barra de 16 y sí va a tener que recordarlos a todos. Entonces, sí va a tener que estar preparado para tener grandes vecindades en el caso de este, ¿no? En el caso que tenga que resolver un montón de vecinos a los cuales tiene que almacenar esta relación. Y es importante que no haga overflow, que tenga el tamaño adecuado, porque si hace overflow... ¿Cómo limpia un caché overflows? ¿Alguien conoce cuál es el algoritmo más usado para limpiar un caché por overflow? Tiene tres letritas. No. LRU. Least Recently Used. Ah, sí. Ah, bueno, es un caché. Vos tenés un problema del caché. Recuerden, todo caché tiene las dos dimensiones, tamaño y tiempo. Y de pronto tengo... El caché mide 10 y viene la entrada 11A. Tengo que sacrificar uno. ¿Cuál sacrifico? El más viejo. El más viejo. El que se ha usado menos recientemente. Más viejo. Bueno, lo sacrifico. No al más nuevo. En este caso, porque si no, básicamente siempre estaría sacrificando el que más me sirve. Entonces, nada, es como para mostrarles a ustedes cómo se aplican problemas en general que tienen que resolver en otros ámbitos de aplicación, como puede ser un caché. Pero esto no deja de ser un caché con todos sus problemas. Entonces, volviendo a este caso particular, este router bien tiene que tener dimensionado o preconfigurado para tener un caché de ARP, de solución ARP, suficientemente grande como para el problema que tiene que resolver. Y los dispositivos estos, si se quiere, lo que hablábamos recientemente, dispositivos Wi-Fi, sea un celu o lo que fuera, solamente tienen que tener una capacidad suficiente como para resolver, en este caso, el router de la red. A menos que, como les comentaba, haya algún otro problema para necesitar comunicarse con toda una vecindad. ARP, en realidad, este es lo que sería, lo que acá le hemos puesto ARP clásico. ARP tiene otros usos que ya han quedado como legacy, excepto algunos que están acá. Lo vamos a mencionar este cuando veamos el HCP. Planeamos verlo luego del regreso del recreo, que ya nos lo vamos a tomar acá un break. Hay un par, además, que me gustaría mencionar. Si yo fuera un buen ciudadano, y yo sé que me estoy yendo, como puede ser cuando estoy a punto, entonces, cerrando el lead de la máquina, así, yo podría, tengo la posibilidad de decirle a la red, "Red, olvídense de este mapeo de IP a MAC, porque me fui de esta red". Terminó la clase, yo bajo acá, me voy, y yo ahí, justo antes, en el último respiro, mando un unARP diciéndole, "olvídense de mí, esta relación que ustedes habían almacenado de mí, especialmente el router, que es el que más he usado típicamente, de IP a MAC, olvídense, ya me fui de acá". Eso se sigue usando. La pregunta es, en broadcast, en unicas, ¿qué les parece? Supongo que a los que yo tengo en mi tabla, que me he comunicado, digamos. Quiere decir que cuando estoy cerrando el lead, me estoy yendo, así, suspendiendo la máquina. Si tengo 20 en mi tabla, tengo que mandar los 20, no sé qué, no sé qué. Ah, entonces, en broadcast. En broadcast, y le digo, entre comillas, a la red, a mi vecindad, le digo, "me fui". Entonces, básicamente, ¿y cómo se llama eso en terminología de cache? ¿Cómo se llama eso? De vuelta, no deja de ser un problema de caching. Cache invalidation. Si acá ocurrió una acción, quien conoce la entrada de cache, que está invalidando esa entrada de cache a quienes lo tienen. Le está diciendo "borralos". Es como casi una llamada remota de procedimiento, donde le dice "borra la entrada de cache". Cache invalidation. Ese es el ANARP y tiene ese caso de uso. Y el gratuitus ARP, en realidad es un refresh, para decir, acá estoy. ¿Cuál de los dos será, de los ARP que vimos? ¿Será un request o un reply? ¿Qué les parece? A ver si lo encuentro acá. ¿Dónde está, maldito? Acá. Este. ¿Dónde está el ARP? Este. Acá recordemos que había un request y había un reply. Si esto es un, hay un caso particular, este se llama gratitus ARP. Y es refresh. ¿Cuál de los dos será? ¿El primero o el segundo? Básicamente así como el otro era "olvídense de mí", este es un "no me olviden, por favor". ¿Es una pregunta o una respuesta? No está esperando respuesta, así que no sé. Es una respuesta, es una respuesta no pedida, por eso es gratuitus. Gratitus. Es una respuesta gratis. ¿Quién te preguntó, macho? Pero bueno, yo digo, porque tengo un ego altísimo, como dispositivo, y le digo a la red, "yo sigo estando acá, yo sigo estando acá". Este puede ser un caso de uso de un router, por ejemplo, no se usa mucho, pero podría ser un caso de uso para mantener refrescada la entrada que tienen el cache, las máquinas que me usan, para mantenerla fresquita. Cuando hablamos de LRU, "List Recent Uses", es como para hacer un refresh de esa entrada, y decir, "sigo estando acá, sigo estando acá", para que no expire esa entrada. O sea, hay que encontrar una víctima para expirar, porque LRU no se elija esa, se mantenga calentita. "Warm it up", ¿no? Un cache calentito de esa entrada. Para eso sería un "Gratitus ARP", decir, "yo estoy acá, sigo estando acá", es como una respuesta no preguntada. Y los otros casos son un poco más catatónicos, o ya en el olvido, legacy. Excepto este, que ya lo veremos cuando veamos de HCP, luego que vengamos del break que nos vamos a tomar ahora. Porque ahora ya nos queda de HCP, nos queda ver de HCP, que esto va a ser unos 15 minutos, vamos a ver, relativamente rápido. Y después ya Diego nos va a contar un poco más de la pictura completa del Router Internet, súper interesante, se va a poner un poquito más simpática el tópico. Y 35, volvemos en 15, ¿les parece a las -10? 8, -10, así tratamos de terminar en tiempo. OK. Bueno. OK. Voy a cortar la grabación, ¿sabés? Dale, perfecto. [AUDIO_EN_BLANCO]