Bueno, retomando, lo que queremos hacer es cómo modelamos, pasamos de este problema que está resuelto en papel, por decirlo de alguna manera, y lo queremos modelar y hacerlo animado. A algunos se les ocurre cómo lo haría y nos cuentan qué podemos usar, cómo lo haría. Es para no mostrárselo a ellos y yo sé cómo hacerlo. Me gustaría que cada uno… Hola, ¿estamos acá o no estamos acá? Sí, profe, yo no pude realmente… Intenté pero no me salió. ¿Qué sería? Pero cuéntenme, quiero que me digan qué intentaron, qué intentarían hacer como para ver cómo se resolvería. Profe, yo en MiniEdit traté de crear un switch, pero no sé… ¿Se puede poner dos direcciones para los switches en MiniEdit? No, switch no, router también como no. Router, perdón. No, pero es parte de lo que queremos resolver. Pero por eso, quiero que me digan a ver cómo harían, porque… ¿Qué pueden dibujar con el MiniEdit y qué dificultad puede ser que tengan? Recuerden que dijimos que íbamos a hacer dos sucursales, ¿qué habría que poner? Un router central y después dos routers para cada una de las sucursales. En realidad si son dos sucursales no haría falta un router central, podríamos conectar esos dos routers directamente. No quiero eso, no dije que se puede hacer eso, nunca dije que se puede hacer eso. Un router central y un router en cada una de las sucursales. No, y la máquina. ¿Qué tiene dibujado esto? Acá tienen que poner un router central, un enlace a otro router, una red que hay acá y un host. El otro router, esta red y otro host. Es decir que acá tienen uno, dos, tres, cuatro, cinco equipos… No estabas presentando, Diego, no sé si te estabas guiando por lo que… Sí, estaba dibujando en el aire, perdón. Gracias por avisar. Tenemos que hacer un host, este host, el router, otro router, otro router y otro host. ¿Qué es lo que ven que se les dificulta y que lo que no han podido resolver? Si el otro día vimos cómo hacer… Yo el profe pude capearle el IP al host, pero después no pude cambiárselo al router y lo que hice fue asignarle un IP desde el archivo con BIM, pero hasta ahí llegué. A ver… Ahí estuvimos probando y hablando por el grupo de WhatsApp con los chicos y porque como que desde la interfaz no podíamos configurar el router, digamos. Entonces por eso nos fuimos a fijar al archivo .py y tampoco no sabemos cómo ahí configurar para que tenga lo… A ver, bien, bien. Está claro cuál es la dificultad y… Veamos esto. Yo acá pude agarrar y decir, bueno, el router es lo mismo, es un host. Me está presentando, profe, no sé si… Pero de nuevo, perdón. Vámonos. Ok, ahí vamos. Abrí mi mininet y me puse acá. Está bien. El host lo puedo hacer con… es lo mismo, para el mininet es todo un host. Acá cada router es otro host y después tengo otro host. Acá hay un switch, otro switch. Todos coinciden que esta red es así. Está bien. Es decir, acá hay un cable porque esto es un switch, acá hay un switch, acá hay otro cable, otro cable, otro cable, otro cable, otro cable. Si quiero puedo agarrar y para ponerlo más bonito le puedo poner que este se llama R central, router central. A este le puedo poner R sub 1. Le podría poner… Esto es lo que le está pasando, que no le están poniendo un IP, pero supónganse que le queremos poner… A este le puedo poner 192.168.101. Era este. 101/24. Barra 29. A este le queremos poner… Router sucursal 2. 192.168.100. Si este era 1, son 8 más allá. 9/29. Una cosa así. Y después, este es host sucursal 1. Dijimos que este era el 10/10. 1/254/24. Ok. Y el host de la sucursal 2 le vamos a poner… Host sucursal 2. 10/10. ¿Cuánto? 2. ¿Cuánto? 2/54. Barra 24. Ok. Era 10/0, profe. Bueno, lo mismo, pero… No, no era… Ah, 10/0, perdón. Sí, no es lo mismo. Gracias por avisar. 10/0. Bueno, esto es así. ¿Qué podía hacer con esto? Bueno, dijimos que esto lo puedo grabar. Le voy a poner caso 2. Y puedo mandar a que genere el código. Export, level 2, script. Le voy a llamar caso 2. Listo. Está grabado. Voy a salir de acá. ¿Qué podía hacer con esto? Bueno, lo puedo correr. A ver si es vivible lo que armé. Puedo poner sudo python caso 2 python. Esto dice que tiene… Ha creado esos hosts. Entonces, ¿cómo hago para meterme en cabo esto? Voy a poner Xtem, router central. Y estoy adentro del router central. Le pongo medium, le pongo large. ¿Se ve bien ahí? Sí, se ve bien. Se ve claro que tiene… A ver, esto tiene las interfaces, lo que pasa es que tiene cualquier IP. Tiene una que es la eth0 y otra que es la eth1. Tiene dos interfaces, es decir que les hizo las placas. De hecho, fíjense, ustedes pueden preguntarle acá a Mininet que les dibuje cómo está hecha la red. Le puse net y me dice "mirá, tengo el router de la sucursal 2 que tiene la interfaz eth0 al switch 4 y eth2". Me muestra más o menos cómo está la red. Yo le puedo poner acá cuáles son los nodos que hay acá. La pregunta es, ustedes dicen los switch no llevan IP. ¿O llevan IP los switch? ¿Llevan IP los switch? No. No, porque son switch. Vamos a ponerle que nos queremos meter Xtern host sucursal 1, IP adres. Vamos a poner más grande para que se vea. Este tiene bien la IP. Con quién tendría que hablar este? El host de la sucursal 1 tendría que hablar con quién? Con el router de la sucursal 1. A ver, entonces me dice Xtern, R sucursal 1. Se acuerdan que le pusimos un IP a este. Le pusimos un IP o no? IP adres. ¿Cuál de estas dos interfaces que tiene este router? Tiene dos interfaces el router. Se ve que tiene esta que da la 1 y esta a dónde da. Esta interfaz es la que se ve con este. ¿Qué podría hacer para probar si se ven? Un ping. ¿A quién? ¿Qué IP tiene esta interfaz? No la tiene. Esta interfaz no tiene IP porque no se la pusieron nunca a ustedes. ¿Qué IP tiene que tener esta interfaz para poder hablar con esta? Le estoy preguntando, ¿qué IP tiene que tener? Está dibujada en el dibujo 800 millones de veces. ¿Qué IP tiene que tener? Para verse con este. La 10.10.1.1. Igual esa red está configurada como 10.10. El de al lado sale como 10.10. Bueno, le pongo 10.10 para que veamos. 10.10. Tengo que asignarme una IP en esta interfaz. Entonces yo le hago ip address add 10.10.1.1/24 al device rsucursal1-eth1-brd+ Este es el comando que asigna una IP con el comando IP address. Estoy sumando la IP a esta interfaz, que es la que se ve con esta otra interfaz. ¿Qué podría probar ahora? Bueno, 10.10.1.254. Ahí. Y de este lado, el pin 10.10.1. Perdón, 10.10. 10.10.1.1. Y también responde. Bueno, acá yo he hecho esto a mano. Lo que nos gustaría hacer es, ¿cómo podemos hacer para que... ¿De dónde salió toda esta configuración? ¿Quién prendió esta configuración? ¿Quién la hizo andar? Que es un poco lo que contaban que estuvieran haciendo. El archivo Python. Ok, es decir que en este archivo, de alguna manera está... Fíjense, ¿qué hace este archivo? Si lo miráramos, ¿qué creen que está haciendo? Ahí se encuentra toda la configuración de la red. Por eso, pero vamos a la... Está usando una librería, que son las librerías de Mininet. ¿Está bien? Que tienen, al hacer prompt Mininet, import Mininet, y simplemente este objeto lo puede crear, el objeto net. Es una instancia de la clase Mininet que le importó acá. Y después fíjense que todo lo demás hace net, está llamando a métodos de este mismo objeto. ¿Esto qué hace? ¿Qué creen que hace esto? Crea un switch. ¿Esto qué hace? Crea un host. Esto le tira un cable entre Router Central y el Switch 1. Este tira un enlace entre el Switch 1 y el R Sucursal 1. ¿Qué harían como programadores? ¿Qué es lo que habría que buscar? Que está bien lo que estaban pensando y es lo que quiero que hagan. Y configurar ese archivo para crear la red. Eso ya crea la red. ¿Qué es lo que no está bien todavía? Que lo vimos recién. Y todo lo que sería la parte del ruteo. No, no, no. Pero hay un problema anterior que no tienen resuelto. Que lo dijeron ustedes. Asignarle la IP al equipo. Claro, por eso. Está faltando en algún lado. ¿Qué es lo que falta? Cómo le asignamos... Claramente, por ejemplo, el host que se llama R Sucursal 2 tiene dos interfaces. Pero yo le estoy asignando una sola IP acá. El R Sucursal 1 también tiene dos interfaces y le estoy asignando una sola IP. ¿A dónde podría ir a buscar para saber si...? ¿Qué dijo el profe? ¿Que se le cortó? ¿A dónde podría ir a buscar? A ver, estoy tratando... Hasta acá vengo haciendo todo si se dan cuenta en esta clase. Le hice yo el dibujo, le hice yo la primera dirección IP. Quiero que pongan su parte del problema para ver cómo lo resolvemos. Porque es un práctico de la materia. Está claro que... Primero, les digo, esto se puede resolver. Tiene solución. Tenemos un problema de software, en realidad, acá. ¿Qué es lo que nos está faltando? Nos está faltando poder... Agregarle otra IP. ¿Y a dónde hay que ir a buscar para saber si se puede agregar IP? En los links. Al manual. ¿A dónde? Por eso. ¿A dónde habría que ir a buscar? ¿Al manual de quién? De Mininet, la documentación de Mininet. Entonces, hay que ir a buscar la documentación. Lo voy a dejar acá, porque quiero que lo resuelvan ustedes. No lo quiero hacer yo. Así que vamos a hacer así. Este problema lo voy a cortar acá. Quiero que la clase que viene lo traigan resuelto. Pero traten de hacerlo ustedes. Es el mismo problema del año pasado. Si van y lo buscan, hagan el esfuerzo de poner la parte de ustedes. Están poniendo poco de parte ustedes. En serio, les pedimos, por favor, que repasen las cosas. Primero, todas las clases, quiero que entren antes de entrar a la clase y revisen su instancia, que estén las cosas instaladas bien, que estén prendidas. No podemos estar, "Ah, profe, que a mí no me conecta". Que a mí, ¿cómo fue la palabra que usamos? "No me engancha", dijo alguien. No es lenguaje cuarto año ese. Porfa. Me tienen que poner su parte. Porque no es una materia... Para que ustedes hayan una idea, es como si estuviéramos haciendo, teniendo que estar a explicarles cómo sumar y restar, y queremos hacer integrales con ustedes. Queremos ver cloud, queremos ver un montón de temas, pero la verdad que están muy verdes para que podamos ver esos temas. Pónganse todo a estudiar de cabeza. Profe. Sí. Una pregunta. ¿Por qué usted en Mininet, cuando hizo el diagrama, usó host y no ahí había una herramienta que decía legacy router? Porque no me deja cambiar el nombre. Y yo sé que es la misma. La primitiva es la misma, miren. Te lo muestro acá. Pero lo aprendí porque... lo aprendí... Es decir, quiero que piensen como programadores. Están pensando como técnicos. Como técnicos de la Academia Pitman. No están pensando con enfoque de programadores. Si yo hago esto, mira esto. Pongo un host y voy a poner un router. Lo voy a grabar. ¿Qué haría yo pensando como programador? Lo grabo. Le pongo test. Le pongo que lo exporte. Pongo un script, le llamo test. Y me voy a mirar qué metió en test. Perdón. ¿Se puso un switch? No, un switch. Me quería poner un router. Perdón. Esto es lo que quería hacer. Pongo un host y pongo un router. Ahora lo voy a hacer. Esto es lo que quería hacer. Pongo un host y pongo un router. Lo voy a grabar como test. Ok. Y ahora lo voy a exportar. Esto lo hicimos en la clase pasada. Pusimos host y router. Pero fíjense que si yo miro el archivo test. Pero... No. R3 es add host. Mirá. Y H1 también es la primitiva host. Es lo mismo. No sé si se ve. Sí, sí, sí. Está bien. Entonces, de hecho, esto... Acá hay un poquito más de pistas para cosas que ustedes decían. Esto es realmente lo que transforma a este host en router. Le está dando un comando al sistema operativo y le está diciendo que prenda el forwardeo de paquetes. Pero la primitiva es la misma. Por eso puse host. Es lo mismo. Me parece bueno para que traten de conceptualizarlo ustedes. La punta del ovillo es esa. Yo iría a buscar la documentación de MiniNet y debería ver cómo hago para sumarle algún IP. Pero quisiera que lo resuelva cada uno y lo compartimos la semana que viene. Porque el caso 2 lo tienen que resolver ustedes. ¿Ok? Perfecto, profe. Buenísimo. Siempre, siempre. Bien. Bueno, no sé si te parece, Juan. Si querés podemos retomar el camino en términos de teoría de que examinemos la parte de datagrama IP como para completar esta horita que queda. Dale, dale. ¿Te parece? Sí, bien, pa, pa. De paso, ya que los tenemos a los muchachos también, como para ir picoteando a medida que vamos viendo la cabecera. Hacer algunos ejemplos, hacer referencia a lo que tenemos en las consolas. Bueno. Dale, Barro. Dame un momento. Eso, dale, eso. Eso, volteé la pantalla. Tengo un momentico que... Tenés, creo que tenés en las diapos, las diapos que están en, pero no están visibles, está en las azules, creo que son. Está la... Ya te digo, Barro. Sí. Tele. Sí, era, va, ahí este... Sí, teníamos la diapos. Ah, está en la misma, está en la cabecera. Ah, sí está. No, sí que está. Hay que retomar en donde habíamos dejado el puntero, por decirlo de una manera. No, esto. Tenés, los que están en la cátera, en los que dicen... Perdón, los que dicen, en la sesión, que están en la sesión 3. De 2020. Sí, sesión 3, datagrama IP que está visible. Les slides de datagrama IP 0416, página 11. Eso, a ver, pará. Sí, claro. Ahí retomamos. Más específicamente para que saco... Presentar una ventana, a ver si le puedo... Siempre le pillo a la ventana que quiero presentar. Creo que es esa. No se puede compartir, permiso. Puto maco ese, la con... Perdón, estamos grabando. Sistema operativo del orto, por favor. Segundo. Ahí vamos. Si me permiten una pestaña. Ahí, quizás, ahí capaz. Ese es. Yo voy a acomodar que quede visible esa diapo para la sesión 4, que es la de hoy. Bueno, dale. Sí, totally. Sí, totally. Sí, totally. Bueno, para que me reorganizo un toque acá las... En realidad lo que debería hacer es... Un segundito. Vamos a necesitar sesión, lo que pasa es que tengo el escritorio lleno de otras cosas. Bueno, no importa. Eso no importa. Vamos switchando en todo caso entre una y otra. Bien. Entonces. Contexto. ¿De qué vamos a hablar ahora? Nosotros ya habíamos visto este diagrama, el que tanto hacemos referencia. Acá tenemos los end systems, acá en el medio los routers que hemos visto. Y lo que vamos a ver ahora es qué formato tiene que tener este datagrama IP. Que como bien decían ustedes, no cambia de origen a destino. En realidad vamos a ver que sí cambian unos pequeños bits, pero no cambia fundamentalmente. Entonces, como todo protocolo tiene que estar escrito de alguna manera. Y lo que vamos a ver ahora es cómo se escribe esa cabecera. Entonces vamos con la primera pregunta. ¿Cuánto mide esa cabecera sin opciones? Tal como la tiene en la pantalla. Así. Fresquito la pregunta, frío la pregunta. ¿Cómo es? ¿Cuánto miden de bytes? Pero para, ahora. Ponele presentar, Juan. No, no, ahí en el botón presentar, ponele que se ve la pantalla. Ah, listo. Está bien, perfecto. Porque se ve súper... Ah, ahí está. Ahí está. Bien, perfecto. Dale. ¿Cuánto mide la cabecera IP? Lo que estamos viendo son secuencias de bits. Sí, cada una de esas marquitas verticales. ¿Cómo se hacía acá para tener...? ¿Se ve mi cursor acá al mouse, no? Sí, se ve. Perfecto. Cada una de estas marquitas es un bit. Pero yo no voy a pretender que cuenten todos los bits. Tenemos alguna referencia de cuánto mide esto. Y acá tenemos... Lo que yo le pido es, ¿La cabecera IP vendría a ser todo este bloque? Acá, ésta. Y lo que le pido es que me digan cuánto mide... ...la cabecera IP. Podría ser los octetos, los bytes, que vamos a poner ahí en la cabecera para que lo que sea que cargue pueda viajar de origen a destino. ¿Cuánto mide? 32. ¿Qué? Bits. 32 bits es un renglón. Y eso no alcanza para la cabecera IP. De hecho, no te entraría en las direcciones de origen y destino de 32 bits, porque cada una es de 32 bits. Cada renglón mide 32 bits, porque vas del 0 hasta el 31. Así que ahí está numerado. 6, sin opciones. Está bien. Admito 6, pero no 6 bytes. ¿Cuánto es el ancho de este renglón? 4 bytes. Ok, ahí vamos. 4 bytes, que son 32 bits. ¿Cuánto es el alto de esto? 24 bytes sería. Ok, perfecto. Sin opciones yo les había pedido, porque las opciones, esto en realidad es elástico, es plástico. Sin el último renglón de opciones. ¿Cuánto mide la cabecera IP? 16. 20. 20, bien. 20 bytes. 20 bytes, porque tenemos 32 bits, que son 4 bytes de ancho. Y el alto acá son 5, sin opciones. Nuevamente son 5 renglones. 1, 2, 3, 4, 5. 5 por 4, 20. 20 bytes. Eso es mucho, es poco. Es el mínimo, ¿no? El mínimo, sí. Menos de eso ya no podés construir una cabecera, de hecho. Porque fíjate que el destination address es el último renglón. Y es el mínimo requerido. La pregunta es tramposita, como son nuestras preguntas, ¿no? ¿Es mucho, es poco, 20? La segunda pregunta, que es la que esperaría que ustedes me hubieran re-preguntado, es respecto de qué. Claro, sí, voy a decir. Bien, ok. Díganlo, díganlo. Respecto de qué, ¿con qué lo podríamos comparar ese 20 contra 100? ¿Contra 100? ¿Contra 10? ¿Qué es un número razonable de limitación que conocemos física, de tamaños de plotagrama, o de tramas? ¿Qué número les suena en la cabeza, así de decir, "y no, en esta red en realidad hay que meter", yo lo voy a poner entre comillas, "paquetes de hasta bytes". ¿Qué es? ¿Ethernet? ¿Cuál es la limitación de tamaño máximo de paquete de Ethernet? ¿1500? 1500, perfecto. Perfecto, 1500. Bien, redondemos así, muy a lo bruto, porque a mí me gusta que tengamos órdenes magnitudes en la cabeza, no me hacen falta los números exactos, pero al menos en este contexto, órdenes magnitudes, pongámosle 2000. Y esto mide 20, quiere decir que es un 1%, poquito más, porque es 1500, 1,5% de cabecera respecto de todo lo que yo puedo llenar una trama bien, bien llena en Ethernet. De 1500 yo ocupo 20. Entonces, ahora va la pregunta, es chico, grande, ¿qué les parece? Chico. Chico, ¿no? Bien, y es algo... Perfecto, y es algo que buscamos, ¿no? Voy a decir una estupidez, si la cabecera tú mira 1000 bytes, te ocuparía más la cabecera que lo que podés cargar, nuevamente en una trama, en la tecnología más común difundida que es Ethernet. Sabemos que IP es independiente del medio, pero IP trata como es el medio y trata que sus datagramas entren... Yo voy a ponerle el poder entre comillas, "cómodos" en la trama, en las tramas de las redes que usa. En trama de Ethernet, 1520, bien chiquitito. Perfecto. ¿Qué onda si yo tengo que transferir un archivo, por ejemplo... Pongámosle, vamos a hacer números súper redondos, ¿no? Son 1500 bytes que tiene, un archivo de 1,5 mega de una máquina a otra, conectar a la misma Ethernet. ¿Hay algún problema si transfiero de un byte, con paquetitos de un byte, versus tratar de mandar paquetitos de 1500? ¿Es lo mismo? Y si mando muchos paquetes, ¿va a haber mucho trabajo en el medio para redireccionarlos? Para procesarlo, no sé si redireccionarlo. En este caso, el ejemplo que di, las máquinas estaban en la misma red, así que no hay ninguna redirección. Pero, ¿dónde pongo el estrés? ¿Cuál es el escenario? Estoy comparando. Tengo que mandar, a ver, números. 1500 bytes, tengo que mandar un archivo de 1,5 mega. ¿Cuántos, si llenado a todas esas tramas, cuántos paquetes son? ¿Diez? De 1500 bytes a 1,5 mega, tengo... Si divido 1,5 mega, divido 1,5k, tengo mil. ¿Sí? Mil. Muchachos, también, orden de magnitud, matemática. Es otra cosa importante a tener en cuenta. Bien, mil. Mil paquetes y yo logro llenarlos completos. Si en realidad, si en vez de eso yo... Imagínense una aplicación, nuevamente insistiendo mucho en lo que siempre insistimos, especialmente Diego, haga una aplicación que básicamente hace un while read del archivo, lee un byte y escribe un byte. Y fuerza que ese byte viaje por la red, ¿no? While read character del archivo abierto, le envía un character por la red. ¿Cuántos paquetes usaría para este archivo de 1,5 mega? ¿Un mil? ¿Lo dijimos los 100, no? Sí, sí, pero si los escribo de un byte. ¿15 mil? ¿Puede ser? No. 15.000.1,5 mega es un millón y medio. Un millón y medio de paquetes. Estamos hablando de un millón y medio de datagramas versus mil datagramas. ¿Qué quiero estresar con esto? Y es algo que van a ver que comúnmente hacemos de ir a los extremos para entender cuál es el problema. Acá hay un problema que nosotros vamos a ver en todo el stack de protocolos, que la primera optimización que tenemos que hacer es tratar de usar al máximo lo que el medio nos provee. En este caso, Ethernet, por ejemplo, nos va a proveer 1.500 de tamaño de trama. Entonces, van a ver que el protocolo en general, sobre todo los protocolos de transporte, van a ser un millón y medio de protocolos. Y en general, sobre todo los protocolos de transporte, van a ser un esfuerzo importante para tratar de llenar esas tramas, hacer unos datagramas lo más grandes posibles para evitar el overhead de las cabeceras. Porque si a mí me pesa mucho más la cabecera que lo que transporto, ¿cómo sería, por ejemplo, en números, un datagrama que está llevando un byte de una punta a otra? ¿Cuánto me diría? Dejemos la parte de transporte de lado. Imaginemos, lo cual no es cierto, porque faltan otras cabeceras, pero por ahora, con lo que conocemos hasta ahora, si pudiera mandar un byte a través de IP, así, genérico, ¿cuál sería el tamaño total de ese datagrama final y cuánto ocuparía la cabecera? 21 y 20 en la cabecera. Claro, una locura. Sí, exacto. Uno sobre 20, estábamos hablando de un 5% de uso del paquete, ¿no? En datos. 95% de lo que ocupa la cabecera, un 5%. Entonces, ¿se entiende? Estas cabeceras nos van a servir para transportar el paquete, pero es importante el esfuerzo que va a hacer todo el stack para tratar de hacer que el payload, ¿qué es payload? La palabra payload, ¿qué significa en inglés? Carga. Carga, perfecto. El payload es lo que va detrás de esa cabecera, ser lo más grande posible. Bien, vamos entonces. Arranquemos. Lo que vemos ahí es una secuencia de bits. Ustedes ya han visto, el año pasado han hecho Wild Shark, creo que han hecho y han visto la cabecera, y le han desplegado a la cabecera. Lo que estamos viendo ahora es ese formato. Estos son todos bits, uno tras otro. ¿Yo puedo hacer overlay acá? No, no puedo hacer overlay, no. ¿Ves qué quería hacer? No, que quiero escribirle arriba esto, debería irme. ¿Me copias la diapo? Porque quiero anotar la cabecera, pero la quiero anotar sobre el whiteboard. Ah, ya te la busco. Ya te la busco. Acá ya te la busco. No, acá estoy haciendo la copia. Si me pasás nomás la-- No, la voy a buscar en la RFC. Que es el Arteaki. No, no, no. En realidad, lo que quería era que me pases de vuelta el link del whiteboard. Pero acá lo tengo. Acá creo que lo tengo. No, todo bien. Ah, o debería estar acá como el Jamboard. No, abrir otro. Bueno, como quiera, abrir otro. Si abro otro, dale. Dale, dale, José. Un segundito. Yo ya estoy pegando la pizarra del otro que hicimos. Así que-- Ah, empiezo una pizarra nueva. Dale, perfecto. Dale. Compartir. Ahí viene una pizarra, pero seguramente acá tengo que hacer un share this tab instead. Ahora, ¿se ve la pizarrita esta? Sí, ahí se ve. Sí, se ve. Perfecto. Buenísimo. Voy a pegar entonces acá. Vamos, niño. Ahí está. Excelente. Esto es lo que quería. Porque voy a borronearlo un poco. Vamos a borronearlo, ensuciarlo un poco. Bien. OK. Versión. ¿Qué versión de protocolo estamos estudiando ahora? ¿Qué versión de IP estamos estudiando ahora? 4. Versión 4. Bueno, entonces díctenme cómo tengo que escribir los bits acá en donde dice versión. Me van dictando, por favor. 0100. ¿Por qué es eso? Acabo-- Alguien me dijo 01. A ver si lo puedo hacer con otro color. Un segundito. Switchar color. ¿Cómo se switcha color? Ahí en el texto mismo. Uno, teniendo apretado. Arriba, arriba en la letra, mirá. Ahí está la A. Arriba en la barra al lado de normal. Ahí cambiá el color de la letra. Ah, perfecto. Gracias. Buenísimo. Ahí vamos. Ahora. Vamos a ver si se ve bien. Entonces, alguien me sopló ahí que yo debería escribir acá. 01. ¿Cómo era? 00. Vamos a poner con un bold. No sé si puedo bold. Me parece que no. No, lo que pasa es que se me va a ir demasiado el tamaño. Déjame ver si lo puedo boldear con Control + V. No. Bueno, no importa. Se ve ahí. ¿Por qué es 0100? ¿Qué tiene mágico ese número? Yo se lo soplé acá al compañero. ¿Qué es 0100? 4 en binario. Ajá. Y ¿cómo tendrá que escribir ahí IPv6? 0110. 0110. Perfecto. Bien, perfecto. ¿Qué tiene que hacer? Imagínense que ustedes son el, yo voy a decir así entre comillas, el driver de IP, digamos, o la implementación del stack, a la cual el driver de ethernet le dijo, uy, acabo de detectar que lo que cargo yo, yo si soy ethernet, he visto una trama. Le saco la cabecera al trama y tengo un payload que es el protocolo de capa superior, el protocolo de capa red. Detecto que es IP y se lo tiro IP. IP, este es tu problema. Imagínense que IP tiene una función de entrada que es receiveDatagram, IP receive. De hecho, así es en el kernel del Linux más o menos. ¿Qué es lo primero que tiene que hacer? ¿Qué pasa? ¿O se los pregunto? ¿Cómo, perdón? Leer la versión. OK. Esa va a ser una de las cosas. Tienen que hacer varios chequeos de integridad. Igual que cuando un usuario, fíjense la analogía. Cuando un usuario que ustedes le permiten hacer un input, tienen que limpiar ese input. Acá el input de la función es todo este datagrama que puede venir con cualquier cosa. O alguien exige que lo que entra en la placa de red tenga determinado contenido. >> Y el protocolo le exige que tenga. >> Sí. Pero cualquiera te puede escribir verdura ahí. De hecho, hay maneras de, había, cada vez menos, maneras de hacerle pantallas azules de pánico a algunos sistemas operativos si le escribías cosas incorrectas ahí. Porque faltaba el chequeo de input. ¿Sí? >> El frame check sequence. >> ¿Cómo, perdón? >> Es el frame check sequence. Eso. >> Pero vos fíjate que eso lo único que hace es chequearte la integridad de la trama respecto de lo que escribió el origen sea correcto. Ahora, ¿qué tal si el origen es un atacante que te puso verdura ahí a propósito para hacerte fallar tu, digamos, el driver de IP, por decir, o la función de recibir IP? Porque sabes que el sistema operativo tiene una falla que se le ponga un bit acá o allá, pum, explota. ¿Sí? >> Entendido. >> Entonces, el punto es, todo lo que vamos a ver ahora es importante porque es lo que hace el sistema operativo. La primera operación es desconfiar de lo que recibe. Igual que cuando ustedes hacen un mini input box, creo que todo, ¿no? Tenemos esa actitud. Hay que desconfiar de quién está del otro lado. Porque el que está del otro lado bien podría ser un atacante que puede tratar de hacer un punto y coma, select asterisco from password y traerse todas las passwords de mi aplicación web. Si no, hice un chequeo de integridad de que no tenga determinados caracteres raros lo que me hacen de input. Nuevamente, este es el equivalente. Entonces, entre los chequeos están tamaño, tamaño máximo 20 como vimos y este tipo de cosas. ¿Qué debería ser el protocolo si acá viniera, no sé, 1111? >> Lo agropea el paquete. >> Bien, perfecto. Porque no existe IPB. ¿Cuánto sería el 111? IP versión. >> 9, 9, no, 7. >> No, versión 15. >> No, versión 15. >> Versión 15. IPB 15 no existe, por eso 111 sería incorrecto. Bien, ahí vamos. Se va viendo más o menos por dónde voy. Las diapos en realidad tienen la descripción de esto, pero a mí me gusta hacer esto interactivo de ir y entender cómo está esto escrito. Yo voy a ir salteando de nivel de dificultad las distintas cabeceras. Hay dos cabeceras que son obvias acá. Vamos a ir ahora a esas que son source address y destination address. Acá va a estar la secuencia de bits, obviamente, que representa la dirección IP, que como sabemos, la dirección IP son de 4 bytes, 32 bits, que entran justito obviamente en este renglón. No hay mucho para decir al respecto, excepto cosas como, por ejemplo, ¿cuándo ustedes no admitirían un paquete que acaba de entrar a través de la ethernet? ¿Qué destination address para ustedes sería? Esto huele a verso. Y bien, no, lo descarto. Con un criterio similar a que estos bits estuvieran todos en uno, por ejemplo, de la versión. Un destination. Sí, mi amor. Sí. ¿Cuál podría ser un destination address que decen, no, esto no está bien? La source address. No se me ocurre la verdad. Bueno, es buena, es buena. Alguien que vos veas entrar por el link, uno que tiene el source y el destination, igual suena tramposo, sospechoso. Gracias por las palabras esas. Por ejemplo, podría ser 0, 0, 0. Todo el destination address, todos los bits en cero. No hay un destination address que sea eso. No es ni un broadcast. No es ni una dirección de red. En realidad, como sabemos, es como se pone en una ruta por default. Nuevamente, acá solamente quiero mostrar el hecho del laburo que tiene que hacer la función de entrada desde un datagrama IP respecto al chequeo de integridad. Sigamos con los campos. IHL es Internet Header Length. Medido en renglones. ¿Cuál es el valor mínimo que tiene que tener el IHL? 5. Correcto. ¿Qué pasa si ahí dice 4, por ejemplo? 4 sería también 0, 1, 0, 0. Está mal. Me está verseando. Y tengan presente que es el tamaño de la cabecera, ¿no? No de todo el datagrama. Solamente la cabecera medido en renglones. Quiero decir que acá sí o sí, acá esto va a tener que ser siempre mayor e igual que 5. ¿Sí o sí? Si es 5 tampoco tiene mucho sentido, ¿no? Porque sería como una cabecera suelta que no tiene payload. La idea de IP es que siempre cargue con payload. Pero, bueno, vale el hecho de que es como para recalcar que esto tiene 5. Type of service, vamos a venir después. Total length es todo el tamaño, el tamaño completo posta, real, de un datagrama IP desde acá, desde el primer bit hasta el final. Porque fíjense que total length no es payload length. Entonces ahí va la pregunta, ¿cuál es el tamaño máximo de un datagrama IP? ¿Cuántos bits tengo para expresar ese tamaño? 32. No, fíjate cuánto mide total length. 8 bits. Ah, no, conté otro. Conté otro. Cuánto tenemos ahí. Recuerda que mide 32 todo el renglón y está justo la mitad, por lo tanto este mide-- 16. 16 bits. OK. ¿Cuántos-- expresado en números decimales, cuánto es? 16 bits. ¿Qué cálculo tienen que hacer si tuvieran una calculadora con capacidad binaria? 2 a la 16. OK, 2 a la 16. Regla mnemónica. 2 a la 10 es 1024. 2 a la 10 es 1024. Si ahí le sumo 6 bits, es como 2 a la 6 más. 2 a la 6 es 64, eso es 64K. De todas maneras, estas potencias, 2 a la 16, 2 a la 32, es como que son potencias, es como que casi que ni siquiera habría que pensarlas. 2 a la 16 son los 64K. Entonces, esto lo vamos a anotar acá. Esto tiene un máximo de 2 a la 16, que es igual a 64K. 64K, obviamente estoy redondeando, son kilobytes, pero son 65,532. Bien. Fíjense que eso-- listo. ¿Qué pasa si yo tengo que mandar un archivo que mide más de 64K? No me sirve bien. OK. ¿Quién lo rompe? ¿Quién lo manda? Bien. Está bien. ¿Pero qué capa lo rompe? ¿Capa 3? No. ¿Por qué? Porque tengan presente que, y acá vamos de vuelta al stack, tengan presente que nosotros teníamos enlace, capa de red, que es lo que estamos viendo ahora, capa de transporte y aplicación. La capa de transporte es la que se va a encargar de hacer todas esas adaptaciones. Vos como usuario, uno como usuario, le voy a decir a la capa de transporte, mirá, yo tengo que enviar esto, un archivo, como decíamos recién, de 1,5 megas. Tu problema, ¿cómo te lo arreglas para vertela con el que tenés abajo? Capa de red orientada a paquetes como esta, con determinados tamaños máximos. Entonces, la capa de transporte va a ser la que va a hacer de alguna manera, si quiere, el adaptador entre una vista más continua de lo que yo puedo hacer respecto a lo que me permite como limitación en sí la capa de red. Eso para el caso de protocolos como TCP. Pero vamos a ver que UDP lo conocen, UDP, el otro protocolo, en realidad, tiene una capa de transporte que no enlaza datagramas entre sí. Por lo tanto, UDP tiene como limitación máxima, máximo de 1,64K, porque solamente puede entrar un solo datagrama IP cada paquete UDP. Bien. Vamos a seguir, vamos al time to live y nos vamos a ir a la, vamos a saltar a la consola. Un segundito, déjenme, quiero ver si puedo instalar, hay una extensión que me permite hacer, buenísima esa extensión, Chrome SSH extension. Por alguna razón acá el Mac que estoy usando, duro, no me está permitiendo compartir otras aplicaciones, otras pantallas de otras aplicaciones. Por ese problema que tengo. Un segundo. Pero déjenme ver si, SSH2.arroba, un segundito, ¿dónde tenía? ¿Cuál era el IP que yo tenía acá? 3.251.3.25. Terminal. Launch app. Acá está. New connection. Arroba. No. Segundito. Ah, no, claro, no. Un segundo, me voy a tener que tomar el tiempo para poder compartir esto. Vamos a parar esto. Presentar ahora, porque esto de todas maneras lo voy a necesitar en alguna otra ocasión. Así que vamos con esto. ¿Dónde están las preferencias de sistemas de porquería? OK. Me sorprende mucho que todavía consideren que es user friendly este sistema operativo. En serio, se rasgan la vertidura de que es user friendly. No deja compartir el script. No, sí, pero por ejemplo, ahora que le permito a mi browser compartirlo, me está diciendo quit and reopen. Tengo que salir del navegador y reabrirlo para poder darle permiso de compartir. No. Voy a tener que hacerlo, así que ya vuelvo. Fíjense esas cosas. Le han dado una Mac en el trabajo y está rabiando con la Mac. Se está intentando negar con el sistema operativo. No, no, está negado. No, no, no. En realidad, bueno, no sé si le ha pasado. Si usas Linux durante mucho tiempo, hay cosas que te resultan muy incómodas porque son muy fáciles de hacer cuando te acostumbras a hacerla. Sobre todo el uso de la terminada en Mac no es lo mismo. La verdad que es verdad. No sé, también parece que está sobrevalorada para los desarrolladores el uso de-- Pero, bueno, como que le gusta. ¿Qué pasa si no te gusta? ¿Qué pasa si no te gusta? ¿Qué pasa si no te gusta? ¿Qué pasa si no te gusta? ¿Qué pasa si no te gusta? ¿Qué pasa si no te gusta? ¿Qué pasa si no te gusta? ¿Qué pasa si no te gusta? ¿Qué pasa si no te gusta? ¿Qué pasa si no te gusta? ¿Qué pasa si no te gusta? ¿Qué pasa si no te gusta? ¿Qué pasa si no te gusta? ¿Qué pasa si no te gusta? ¿Qué pasa si no te gusta? ¿Qué pasa si no te gusta? ¿Qué pasa si no te gusta? ¿Qué pasa si no te gusta? ¿Qué pasa si no te gusta? ¿Qué pasa si no te gusta? ¿Qué pasa si no te gusta? ¿Qué pasa si no te gusta? ¿Qué pasa si no te gusta? ¿Qué pasa si no te gusta? ¿Qué pasa si no te gusta? ¿Qué pasa si no te gusta? ¿Qué pasa si no te gusta? ¿Qué pasa si no te gusta? ¿Por qué se le ocurre a ustedes que hace falta eso? Porque por si hay algún error de enrutamiento que no esté saltando de router a router infinitamente. Ok, que se me arme un loop, pero ¿eso es posible? ¿Cómo puede estar tan mal diseñado IP? ¿Es posible, por ejemplo, tener, imagínense, súper simple un triángulo entre routers en el cual la ruta por default, la 00/0, apunte mutuamente entre sí? Entonces un datagrama que entra... ¿Se ven mis manos, no? Sí. Sí, perfecto. Bueno. Un datagrama que entra, imagínense, el triángulo, un datagrama que entra por la punta de arriba del triángulo, va a este y dice "ah, el default router es este al lado", "ah, el default router es este", y el datagrama queda acá atrapado infinitamente. ¿Es posible que las rutas estén tan mal así? Sí, ¿por qué no? Sí, acá yo tengo dominio de administración distinto, también puede ser un error humano, un error de protocolo de ruteo. Como bien hemos estado viendo, uno como humanos, tiene el poder de crear estas entradas en la tabla de ruteo, cada una de las entradas, y bien, pueden estar mal estas entradas, entonces, ¿qué pasaría con un paquete si no tuviera algún mecanismo para evitar esto? Sencillamente estaría ahí para siempre, cada nuevo paquete aumentaría, aumentaría, aumentaría, y hace rato no tendríamos internet si no tuviéramos un mecanismo para evitar eso. Ustedes lo están diseñando ese mecanismo, tienen ese campo que se llama "time to live", voy a volver a presentar en realidad esa... Así lo vemos entre todos. Segundito. ¿Cómo alcanzo con una pestaña? Con esto. Acá... Presentar. Estamos hablando de este campo "time to live", que en realidad no es tiempo, porque acá no hay ningún timer, como ustedes pueden ver en la cabecera no hay ningún tiempo de envío, tiempo de recepción, ni nada, ¿no? Esto es "timeless". ¿Cómo lo diseñarían ustedes eso? Si ya saben cómo funciona, por favor no lo cuenten, no me spoileen. ¿Cómo lo diseñarían ustedes para proveerle a IPS mecanismo de autoprotección frente a eso? Ese es el detalle que usted había dicho que sí cambiaba dentro del paquete. Va a serlo, pero eso es un coro horario de que alguien me cuente cómo funciona. Sí, ese es el que cambia. Piensen que lo están diseñando ustedes, piensen que... Y esto es súper importante, porque esto refuerza el hecho de que esto es "stateless". El problema de cada router, recuerden, empieza y termina con haber forwardeado el datagrama de una interfaz a otra. Me saqué de encima, me llegó, "¿Quién es el próximo?" Se lo tiro al próximo, siempre asumiendo que no se están conectando a mí, no me están administrando como router. Mi problema como router es levantar un datagrama, ver cuál es el destino, y patearle el problema a mi próximo router, o si es el host final, porque yo soy el vecino del host final, tirárselo al host final. Pero mi problema es sacarme los datagramas de encima rápido y pasarlos. Mi problema empieza y termina en cada datagrama. Yo como router tengo posibilidad de escribir esta cabecera y voy a tener permiso de todas las cosas que no puedo escribir, no puedo tocar esta cabecera, voy a tener permiso y voy a deber tocar esa cabecera "time to leave". ¿Sí? Con esa especificación, ¿qué harían ustedes? ¿Cómo, qué reglas pondrían, cómo lo harían para evitar esto que estamos hablando de que llegue un punto en el cual pueda quedar para siempre loopeando datagrama IP? Y cuando se manda empieza con todo en cero, y cada vez que se abre le va sumando uno y cuando llega al límite lo dropea. Bien, bien, podría ser. Bien, está muy bien, está muy bien. En realidad es exactamente al revés, pero está muy bien. Está al revés, claro. Pero bueno, pero eso, ¿por qué es al revés? ¿Cuál es la razón de que sea al revés? Ojo que lo que acaba de mencionar tu compañero, vaya para arriba o vaya para abajo, está muy bien en ambas maneras. Lo primero que hay que hacer es ver qué número tiene. Si es cero, y si dijimos que iba al revés, cuando llega a cero, alguno lo encuentra en cero, lo descarta. Bien. Ojo que está muy bien lo que dijo tu compañero. Bien, podría arrancar, por ejemplo, ¿qué pasara? Vamos a hacer todo el proceso completo. ¿Qué pasara si lo arrancáramos en cero? Siempre. El origen siempre lo pone en cero. ¿Cuántos routers como máximo podría flipar o irse forwardeando hasta que directamente el router, que es el número dentro de esa secuencia de routers, diga, no, loco, ya, ya, se le acabó la nafta a este datagrama? Dos a la ocho veces. Correcto, correcto. 255. 56, pero 255 porque hay uno que va a tener que arrancar en cero y se va sumando y cuando vea todos los bits en uno, lo dropea. Bueno, ese bien podría ser un criterio. Se eligió el criterio de ir para abajo porque no necesariamente queremos que explotar las 255 posibles forwardeos. ¿Cuánto debería ser un número razonable de veces que yo le dejo un paquete de IP pasar por un router? En base a que, ¿cuál es esa escala? ¿Qué le ponemos? ¿2, 10? ¿50? ¿20? Una vez. Quiere decir que si yo mando un paquete a la Internet, pasa por el router acá de mi IP y se dropea. Se le acabó la nafta. Sí, sí, sí, entendí mal. Bien, piensen en el type to leave como la nafta que ustedes le ponen a este datagrama que tiene que pasar. Esa nafta se gasta uno por cada router que pasa. Entonces, el mecanismo es justamente va a cero y quien envía el datagrama tiene la total autoridad para ponerle ahí la cantidad de nafta que quiera. ¿Cuál sería un valor razonable de nafta o comparable con qué sería ese valor? Le ponemos. No depende de a dónde queramos ir en la nafta. Sí, sí, sí, exactamente. Entonces, ¿contra qué debería compararlo así a grandes rasgos? Contra la cantidad de routers. ¿Qué hay entre el inicio y el destino? Entre todos los posibles inicios contra todos los posibles destinos, ¿no? Ah, sí. ¿Sí? OK. Bien. Bueno, básicamente lo voy a decir de lo bruto. El máximo ancho que tenga la Internet medida en routers entre cualquiera puntos. ¿Sí? Ese número, que en realidad es un número que, pobre protocolo, no depende de protocolo, depende de cómo esté el despliegue del routing, la interconectividad de la Internet completa. Ese número más o menos se encontró, se definió que no tiene que ser más de 30 ish, 40. Entonces, hay una RFC que dice que por default todos los iniciadores de un datagrama, los que crean un datagrama IP, le ponen 64. Así. 64. ¿Sí? Uno lo puede ajustar a eso, pero el default es 64. Quiere decir que 64, 63 y se va a ir consumiendo y cuando toca 0, ¿cómo sería la situación? ¿Cuál de todos estos routers, el router que observa eso y dice, "Ux, se te acabó la nafta, flaco, te tiro"? El 63AU. Bien. ¿Qué número va a levantar desde la interfaz por la cual le llega? ¿Qué número va a decir el TTL ahí? O sea, va a ser 7 ceros y un 1 al final. Correcto. 1. Y como la regla es, yo como router te decremento eso en 1 y te dejo seguir y como básicamente ya es 0, se te acabó la nafta. Listo. Dropeo el paquete. El router que observa que el TTL es 1, dropea el paquete. Porque ya básicamente se le acabó la nafta. Entonces, ¿cómo se le ocurre a ustedes que podemos hacer una aplicación tal como... Y ahora sí voy a compartir de vuelta la pantalla, la ventana del Shell. Ahí dice "route -n" Vamos a hacer 3 routes y después vamos a meterlo. Para lo cual ustedes van a tener que hacer lo mismo. Tener sudo apt install Está medio pequeña. Si la podés levantar un poquito. Sí, como lo negro. Ahí vamos. Dale. Se ve mejor en el video. Ahí está. ¿No? No cambió mucho. ¿Eh? Qué loco. Ah, me debe estar cambiando... Claro. Me está cambiando el tamaño completo de la pantalla. Ahí. Ahí. También cambia el tamaño de la pantalla. Ahí va. Ahí mejora. Perfecto. Bueno, ¿qué fue lo que hice? Instale la aplicación esta 3 routes. Voy a hacer esto. 3 routes -n Luego... ¿Cómo? Ahí estamos. Bien. Esa aplicación 3 routes, 3 routes, en realidad abusa de ese campo TTL de la siguiente manera. Cuando un router descarta, porque se le acabó la nafta, no solo descarta sino además ¿qué hace? ¿Qué les parece? Hemos hablado tangencialmente... Devuelve un mensaje que dice que se rompió. ¿Y con qué protocolo devuelve ese mensaje? ¿Recuerdan el nombre del protocolo? ¿UDP? No, ese es un protocolo de transporte y esto es RED. Esta es la RED ayudándose con otro protocolo hermano de RED, el helper de IP, que lo usa para reportar problemas. ¿CIDR? CIDR en realidad es la anotación IP/Máscara. ¿ICMP? ICMP. Recordemos que, y acá viene lo importante entonces, recordemos que la capa IP en sí, el protocolo IP es el que mueve datagramas, pero tiene de respaldo, de ayuda, un protocolo ICMP que también es carga de IP, es payload de IP, pero lo usa para que la RED reporte problemas. Cuando se le acaba la nafta a un datagrama, el router que descarta reporta al origen el problema diciéndole "che, tuve que descartar este datagrama porque el TTL se le acabó". ¿Qué estamos viendo en la pantalla? En la pantalla estamos viendo una traza de las IP de los routers para llegar a determinado destino. Si yo hago un ping acá, ping, doble doble, google com, si ustedes ven es este destino que está acá, que es el mismo de este último destino. Pero a mí me interesa ver cuáles son las IP de los routers que están en el medio, de los intermediarios antes del destino. ¿Cómo usarían ustedes entonces todo lo que acabo de comentar en estos últimos minutos para construir esta aplicación? Esta. Y voy mandando, mando un paquete con un TTL de uno, y después me va a devolver a donde llegó, después le sumo al TTL para dos, para tres, hasta que llegue al destination adres. Ok, y ¿cómo? Ahora vos cuando envías ese, envías por ejemplo un paquete, imagínate que lo haces como un equivalente a un ping, pero vos envías un ping y ¿qué recibís a cambio? ¿El pong? Sí. Bueno, ahí va el punto. Ese ping, ese paquete, ¿a dónde va? ¿Cuál es tu destino? Pensá que vos lo único que sabes en este momento es a dónde querés ir. Lo voy a poner con IPs así no me mete ruido los nombres. Vamos a poner con IPs, una IP de Google, de una pata de Google acá de Buenos Aires. No, no, capaz que es de Rodríguez Peña, me parece. Diego sabe más de esto, capaz que está acá nomás. De qué cosa. No, no, la pata de, no sé si Google al final tiene un POP acá en Rodríguez Peña, acá en el... No, me parece que no. Ah, ok, ok, entonces Buenos Aires. Bueno, anyway, no importa. Piense que para el momento en que yo, yo soy la aplicación de Route, 3Route, me han pasado esta IP, yo lo único que sé es esto. Desconozco totalmente esto. Por lo tanto, yo voy a construir un datagrama IP que va a tener como destino final, el destino que me pasan, como nosotros ahora con el diario del lunes vemos que es un destino muy remoto, pero la aplicación no sabe cuán lejos está. Entonces, construye, por ejemplo, un paquete ping con ese destino. Como bien decía su compañero, le pone ttl=1, es decir, nafta=1. ¿Y qué le va a ocurrir? Cuéntenme cuál es la vida de ese datagrama. Llega el primer hop y ya se que hace un nafta, entonces tiene que devolver una... Perfecto, entonces el primer hop, el primer router lo descarta y devuelve, ¿qué cosa? El pong. No devuelve un pong, porque si devolviera un pong estaría jugando con el... ¿Quién es el único que devuelve un pong acá? El destination address. Claro, cuando yo logro un pong es que ya llegué, pero en el medio yo me fui topando con piedras. Yo tiro un ping, el que me hace pong, y el único que me puede hacer pong es el destino final. Todos los del medio básicamente me fueron insultando en el medio, me fueron diciendo "no llegaste". Entonces yo, lo importante de esto es yo le apunto al final, pero le pongo poca nafta a propósito para que cuando se le termine el ttl, ese router me reporte. Entonces yo acá en la aplicación lo que observo es... ¿Cómo yo como aplicación 3Route puedo escribir esto acá? ¿Qué es lo que leí de este router? Y de este y de este. ¿Qué fue lo que... qué es lo que fui leyendo? ¿Cuánto tiempo tardó en... No, el tiempo es lo que está después, pero fundamentalmente... ¿El reporte de error? Claro, el reporte de error. ¿De quién viene el reporte de error? Yo le apunte allá lejos y en realidad hay alguien en el medio del cual yo desconozco. Piensen que para el momento en que yo escribo y pongo esto no tengo la más absoluta idea de estos. ¿Qué sé yo que son estos? Ni idea. Si no, sencillamente los voy descubriendo porque justamente son los que en el medio me han ido reportando que se le ha terminado el ttl. Entonces la aplicación 3Route es un gran loop en el cual lo que va haciendo va incrementando el ttl de 1, 2, 3, 4. ¿Y cuál es la condición final? Como veo que yo me ya me spoileé, pero bueno. ¿Cómo sé yo que ya llegué al destino? Recibiendo el pong. Recibiendo el pong. Recibiendo el pong y yo digo "ah, listo, ya está, ya los descubrí a todos". Hay una versión, Linux viene medio que bastante por default. Fue una versión un poco más interesante que es mtr. Básicamente hace lo mismo pero de una manera más interactiva. Como ven aquí, en realidad en vez de ser un single shot, un disparo único como fue recién y listo, es como un continuum. Entonces es muy, muy útil para cuando uno está bugeando problemas de red. Porque si uno ve los, fíjense que acá les va mostrando los a medida que ocurre. Si acá hubiera algún tipo de pérdida en el medio, vamos a probar algún destino mucho más lejano, como por ejemplo Japón. Fíjense que ahí hay uno que me está reportando los, acá en el medio, que no necesariamente puede ser que este router de acá esté decidiendo a propósito no reportar tanto por una cuestión de autoprotección frente a ataques. ¿A qué destino le puse? Le puse .co.jp. .co.jp sería lo más parecido al destino por default com de Japón. Uno siempre elige Japón cuando quiere pensar en lejos. ¿Cuántos routers hay en el medio? 20. 18. 19. Porque este acá en el cero soy yo, en el este el destino final, así que serían 19 routers en el medio. Y fíjense también, no está relacionado con lo que estamos viendo en la cabecera, pero también es útil entender un poco aquí las latencias. ¿Cuándo les parece que hemos cambiado de continente? ¿Dónde ven ustedes que hemos entrado en una estiróptica que cruza el...? ¿Por qué? Por el... aumentan ahí los average. Bien, estos son en milisegundos. Y fíjense, el orden de decenas de milisegundos estamos hablando de tierra cercana. Estamos hablando de esto, seguramente la salida de Buenos Aires. Estoy adivinando acá, esto posiblemente sea Brasil o algo por el estilo. Y acá fíjense el salto, 100 milisegundos. Estamos hablando de que hemos posiblemente entre esos dos está todo un cable subterráneo que va quizás desde una pata de Brasil hasta alguna pata en Estados Unidos. ¿Ven algún otro salto por el estilo en donde estemos saltando de continente? Y después, o sea, va de la red 176, después va a la 5. Sí, no, eso sí, pero fíjense que ahí no hay un mapeo... ¿Está bien lo que decís vos? Los periféricos podrían ser, pero están mezclados números, es decir, direcciones IP crudas con DNS. En la 14 a la 15. Ajá, la 14 a la 15 está interesante. Fíjense que hay otro salto de 100 milisegundos. Es muy posible que acá esto sea Estados Unidos y acá... No, no, no, no, no. ¿No sería Japón por el DNS? ¿Cuál? En la 15 y en la 16. Bien, sí, suena a JP. Sí, porque cambia de US a Japón. Y esto en realidad, este CA es seguramente por California. Ahí no sé qué toca, no son los... Esto debe ser costa oeste de Estados Unidos, este. Acá US dice clarito, acá dice .jp. Pero no sé lo que... Ahí les voy a... Ahí, ahí les dice trampa. Está bien eso, porque puede servir de hint, pero yo quería que nos enfocáramos en esto. ¿Sí? Acá. Fíjense que acá nos ha servido para medir la latencia. Entonces, ¿a qué voy con esto? ¿Qué está aplicado? Yo estoy apretando la tecla N que me switchean entre ambas. Por cierto, esto lo pueden hacer ustedes también. Esa era la idea de que lo hagamos en la cloud. Cosa de mostrarles que ustedes también pueden ir haciendo eso si quieren probarlo. Fíjense que acá ya estamos... Ya se está reportando algún loss ahí. Pero les quería mostrar esto, ¿no? De las latencias de las que estamos hablando. Y también un poco los órdenes de magnitud. Fíjense que un TTL de 64 por default, con esta muestra que estamos haciendo de Argentina-Japón, que tiene que cruzarse un buen pedazo de la internet, estamos hablando que tenemos 19, 20 routers entre medio de los dos. Así que 64 es un número que todavía es seguro. Y es el número... Y es la razón por la cual también... Si en algún punto la internet midiera en alguno de sus máximos 70 routers, habría conexiones fallidas realmente. Empezaría, ocurriría esto, no llegarían las conexiones porque hay una RFC. Recuerden que las RFC son las normas, si se quiere, que se han discutido y que establecen cómo tienen que comportarse y cómo se escribe el protocolo. Hay una RFC que dice específicamente que el default es 64. Bien. Y ahí, profe, había 80% de los de paquetes. Sí, como les decía, ahí eso puede ser una actitud de seguridad acá. Este router en particular puede estar decidiendo no reportar el 100% de los errores, sino solamente un subporciento. Porque fíjense que hacia adelante no hay pérdida, es solamente en ese punto. Si acaso tuviera pérdida y la observara el mismo grado de pérdida hacia adelante... ¿No estoy compartiendo? Sí, estoy compartiendo. No, sí, pero recién había también una pérdida. Sí, en uno había un 5%. Me pareció que eran los cambios de continente que habíamos hablado. Igual es que el número de pérdida no lo tomen... Por eso estaba justamente completando la idea. Acá bien puede ser una configuración de seguridad de este router que decida solamente reportar un subporcentaje de ICMP para evitar ataques. ¿Qué es lo que le quería decir? Una cuestión meramente física. Si de este router, si hacia este router hubiera pérdida en el link, yo debería observar esa pérdida propagada hacia adelante. Porque si tengo pérdida hasta ese router, tendría pérdida ese router para atrás. Entonces, un feedback interesante que uno tiene para observar si es que el router está decidiendo no reportar todo, o si es que efectivamente tengo pérdida, es, entre comillas, ¿cuánto se arrastra esa pérdida hacia atrás? Si yo leyera 80% acá y acá y siguiera leyendo en ese orden de magnitud 70, 80 hacia atrás, entonces diríamos, sí, estamos teniendo pérdida desde ahí en adelante. Pero si como estoy leyendo 0 hacia atrás, efectivamente está súper limpio, está buenísimo, no estamos teniendo nada de pérdida. Simplemente que este guacho está decidiendo, este, el 10, está decidiendo no reportar de regreso 100% de los errores. Esto es la pérdida, por ejemplo, recién decía en ese 80% y no sé si era en el 15 o en el 16, decía como 25. Un 5% creo. Llegó a un punto al 21, me quedé a 80. Eso es más de 100%. Eso se lee como 101% o es el 21 de lo que pasó, digamos. No, no, no, pero ahí estás sumando peras con manzanas, con hojas. Eso es siempre en cada router. Pensálo, como siempre decimos, los routers son independientes entre sí. Son todas entidades independientes. Entonces siempre tenemos que pensar en cada una de ellas. Igual lo que está diciendo Juanjo, que ese comando es muy útil, muy útil para hacer análisis. No hay pérdida en el viaje. La única manera que ustedes pudieran garantizar es que todos pierdan de manera equivalente y en realidad es, la manera que ese comando construye esta respuesta es, si todos los routers les respondieran todo lo que ustedes hacen, volcarían a los routers para atender a ustedes para que les anden el MTR. Entonces, por un criterio de seguridad, se protege respondiendo una muestra. Entonces, no es que los enlaces no tienen pérdida acá. De hecho, a ver, si pudiera, el destino, ¿quién es ese destino? Tirale un ping al destino. ¿Quién es? Estaba probando .co.india, .co.jp de Japón. Por eso. No, pero si hay un caso por el destino. Sí, claro. Ven que el destino no pierde. Que es lo que importa. Ok, entendido. A ver, me quedo con las ganas de que pierda, para. Y a los routers siguientes del día 80. Ahí empezó el rock and roll, ahí me gustó el rock and roll. ¿Qué le puse ahí? Le puse que mande un paquete cada 0,1 segundo, porque por default manda cada 1 o 2 segundos. Y nos dice 0,1. ¡Huija! Rock and roll, baby. Now we're talking. Fíjense que hasta le estoy molestando a mi pobrecito AP que tengo acá, ¿no? Que ha dicho, no, loco, no, no te voy a responder todo. Pero fíjense, esto es un comportamiento. Se ve ahí, ¿no? Espero que no me esté auto afectando mi stream. Sí, se ve. Se ve, pero esto es pérdida. Fíjense que a partir de este punto, estamos teniendo consistentemente alrededor de 1% de pérdida. Entonces eso es pérdida en serio. Porque seguramente a partir de acá, de este, voy a frenarlo, esto lo pauso así. Ahí lo pause. Fíjense que esto está buenísimo porque está mostrándole 0,9% desde acá en adelante y muy consistente. Quiere decir que acá sí bien puede ser. Maldición con mi uso del mouse. Vamos de vuelta. Vamos a frenarlo ahí. Es bien consistente la cantidad. Entonces acá sí puedo decir que desde acá para abajo, desde el 14 para abajo, estoy observando alrededor de un 6% de pérdida. Desde el 11 para abajo, alrededor de un 2% de pérdida. ¿Sí? ¿Se entiende? O al menos un 2% y acá al menos un 6%. Y el 83 es un valor como inflado. Por eso les digo, ahí hay algo especial de ese router, porque recién veíamos todo en 0 y ese siempre en 80. Ese router está haciendo algún policing, alguna política para no responder todo ISMP. O capaz que no recibir todo ISMP. El papá tiene un filtro de entrada que cuando le entra este ping dice, no, macho, yo voy a permitir que entren pings uno de cada cinco o uno de cada cinco de cada dirección IP. Que es un filtro que se puede construir por una cuestión de protección, de seguridad, para evitar que le hagan denegación de servicio o ataques. ¿Sí? Bien, buenísimo. Bien, creo que quedó súper bien entendido el-- Esto, vamos a volver a dejar de presentar y presentar-- ¿Esa es la protección que tienen páginas para que no los crasheen así con máquinas virtuales metiéndose 30,000 personas en un segundo? Pueden estar a otras alturas del stack. Depende de qué altura. Esta altura que estamos hablando ahora, estamos en la altura de red, capa 3. Bien. Pero hay para capas 7, perdón, para capa transporte, 4/5. Y para capa 7, que es aplicación. Y cada capa tiene su problema distinto a resolver para protegerse. Bien. No va a ser consistentemente igual. Bien, seguimos. Entonces, vimos time to live. Time to live. Entonces, le vamos a poner una notacióncita acá. Esto es max. Ay, mi colorcito. Ahí. Entonces, vamos, vamos, max. 255 default, igual a 64. Bien. Bien, seguimos. Entonces, protocolo. Pero no estamos hablando del protocolo IP. ¿Por qué tiene que poner protocolo? Tiene que decir, ah, no, yo soy IP. Sí, porque no sabe qué otra cosa puede ser otro protocolo. ¿Qué otro protocolo podría ser? El ICMP que hablábamos recién. Bien, ICMP, payload IP. ¿Qué otro protocolo uno leería ahí, entonces? ¿De qué protocolo estamos hablando? Que se le-- Esta cabecera es cabecera IP. Esto es IPv4. Entonces, ¿qué protocolo especifica ese campo? ¿PIN puede ser uno? No, no, no. Eso es ICMP. Es el protocolo. PIN sería más aplicación o un uso de ese protocolo. ¿Qué protocolo carga IP? Lo vimos en la primera clase. Cuando veíamos las capas, teníamos enlace, Ethernet, red, IPv4. TCP, UDP. Y eso es lo que va a estar escrito ahí. TCP, UDP. Y ICMP también, a pesar de que no es un protocolo de transporte, es carga de IP. Entonces, acá le vamos a poner, por ejemplo, esto sería TCP, UDP. Y lo voy a poner entre paréntesis, ICMP, nomás por el hecho este que mencionamos, de que es un protocolo de red a pesar de ser carga. Eso es lo que va a especificar acá, entonces, de alguna manera. A ver si lo puedo dibujar. ¿Cuál era? Bolígrafo. Este era bolígrafo libre, ¿no? Sí. Y para cambiarte el color. Entonces, este es el protocolo que vendría acá, ¿cierto? Ahí. Justamente especifica qué diablos de protocolo viene como carga de IP. El protocolo del payload. Yo, cabecer IP, estoy cargando una cabecera de un protocolo TCP o UDP. Bien. Sigamos viendo un poquito. Header checksum. ¿Qué indicios le da el header checksum? ¿Qué está chequeando el IP? La integridad de la cabecera. Pero no habíamos dicho que IP no chequeaba nada, que no había chequeo de punta a punta, que el protocolo de transporte era el que chequeaba. Chequea la cabecera. La cabecera. ¿Cuánto mide la cabecera? Mucho, poco. ¿Cuánto habíamos dicho que medía típicamente o mínimo? 20. 20. Bien. Ahora, ¿por qué estos desgraciados que diseñaron el protocolo IP, por qué no dijeron, ya que estábamos haciendo el chequeo, ¿por qué no chequeamos todo el datagrama y listo? ¿Por qué chequear solo la cabecera? ¿Qué les cuesta chequear todo el datagrama? Y eso va a sacar tiempo, porque tiene que hacer procesamiento. Ajá, ok. ¿En qué orden de magnitud de diferencia estamos hablando? Milisegundos. No, no, no. Les pedí el ratio. Estamos hablando de 20 bytes versus cuánto que tendría que chequear cada router. 600. Ok. Ahí estamos. Ahí estamos. Correcto. Entonces, justamente, ¿por qué? Porque la emisión del router, ¿cuál de todos estos campos es el campo más importante para el router? Lo dijo Diego cuando arrancamos la clase. ¿Qué es lo que el router se fija y qué es básicamente el que define su laburo? ¿Cuál de todos estos campos? El destination address. Destination address. Correcto. Es decir que el router, esto, es justamente lo que tiene que leer. Y tienen que estar seguros que no solo eso, sino que todos los otros campos de la cabecera están íntegros. Porque si está algo roto, se flipó un bit, hay algo que está mal, listo. Yo no voy a trabajar con algo que está roto. Y de vuelta, donde pone la lupa el router es solamente en la cabecera. No le interesa el payload. El payload será un problema de otra capa del stack de protocolos. Mi problema como router es garantizar que esto llegue a destino. Y que el resto de la cabecera esté íntegro. Por eso es que es un header checksum. El header checksum, entonces, solamente, como header que es, solamente alcanza a la cabecera. Y yo lo voy a dibujar así específicamente porque estamos hablando de un caso en que no haya opciones. Puede haber opciones, pero para no complicarlo, es como para que quede bien claro que solamente alcanza eso. Bien. Sus adres es simple. Header checksum, type of service. Nos queda este, que es fragmentación. Que es, no estoy seguro si es un concepto para entrarlo, lo voy a hacer una van premiere, ya son las 9. Y lo vamos a ver más en profundidad la clase que viene. Porque es relativamente un poquito más complejo. Eso es si el payload era más grande que lo que podía entrar en el datagrama. No. Entonces, gémelo para la clase que viene. Bien. Les cuento. Les cuento cuál es el escenario de una... Los hosts orígenes no fragmentan. Son súper optimistas los hosts orígenes. Es decir, yo, como host origen, tengo una Ethernet o tengo un Wi-Fi que tiene 1500 de MTU. Yo soy optimista. Si tengo que, por ejemplo, subir una foto a algún... No sé, subir una foto a Instagram, lo que fuera, esa foto, como bien sabemos, mide varios megas, voy a tratar de llenar los paquetes los más gorditos posible por todo lo que ya hablamos. Entonces yo voy, mejor dicho, la estable protocolo, voy a correr mi máquina, voy a escribir datagramas bien gordotes. Tengo una capa Wi-Fi, hasta mi router Wi-Fi, 1500, va dando datagramas llenos 1500. Cuéntame el resto de la historia. Y de hecho, el protocolo IP no fragmenta en origen. Porque la fragmentación, como vamos a ver, es caca, nene. Horrible, tan horrible que no existe ni IPv6. Ish. Pero IPv4 dedicó 32 bits a la fragmentación. Entonces yo escribí acá toda la secuencia, datagramas de 1500. Pero, ¿cuál podría ser el "pero" para el cual necesitemos fragmentación? ¿Estamos seguros que todos los capas de... Si tenemos perdida de datos. No, perdida de datos, perdida es pérdida. Pim, ba, chao, paf. Fin del juego para este datagrama, ¿no? ¿Estamos seguros que todas las capas de enlace, desde acá hasta Instagram.com, tienen 1500 como mínimo? No. ¿Y qué pasará a un router que, ah, qué macana, tengo 1450 en mi próxima capa de enlace y tengo este ñato yo que le mandé un datagrama de 1500? Pero solamente puede escribir un datagrama como máximo 1450 porque resulta que no es internet, es algún otro como un túnel de no sé qué extraño, muy raro que exista, pero existe, el protocolo lo soporta. No entra 1500 en mi próxima capa de enlace. Yo soy el router que recibió por un lado 1500 y mi próxima capa de enlace no entra 1500. Tienen que descortarlo. Ajá, bien. Y es ahí donde actúa la fragmentación. Es decir que la fragmentación en IP en general, en IPv4, está destinada a que los routers en el medio de algo, una posibilidad de romper ese datagrama en pedacitos y que sigan hasta destino. Los datagramitos y que después se reensamblen en destino. Para reconstruir el datagrama original. Pero fragmentación de IP tiene como media horita larga de charla porque hay muchos aspectos interesantes. Por eso, lo quería dejar nomás como avant premier, lo quería dejar planteado al problema, pero lo tomamos la clase que viene. OK. Tenemos, recuerden, porfa, para la clase que viene, vamos a retomar este tema, pero tenemos que traer avanzado la solución del caso 2, que lo vamos a revisar probablemente al principio. Queremos ver eso y queremos cerrar el protocolo IP viendo lo que sería una conceptualización de, bueno, cómo es que funciona la internet y cómo funcionan los protocolos dinámicos que hacen que eso funcione. Entonces, de nuevo les pedimos, miren las clases, repasen las cosas que tenemos, hacemos todo un esfuerzo, si querés, cortamos la grabación. Dale, sí, sí. [AUDIO_EN_BLANCO]